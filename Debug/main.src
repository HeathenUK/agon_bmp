; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optspeed -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\main.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME0",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME1"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME2"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME2",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",8
.DEFINE "baudRate"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "dataBits"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stopBits"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "parity"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flowcontrol"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "eir"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",15
.DEFINE "fs"
.VALUE 0
.CLASS 8
.TYPE 46
.ENDEF
.DEFINE "id"
.VALUE 3
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "attr"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stat"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "sclust"
.VALUE 7
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "objsize"
.VALUE 11
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",36
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME4"
.TYPE 8
.ENDEF
.DEFINE "flag"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "err"
.VALUE 16
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fptr"
.VALUE 17
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 21
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 25
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_sect"
.VALUE 29
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_ptr"
.VALUE 33
.CLASS 8
.TYPE 46
.ENDEF
.ENDREC "NONAME5"
;    1	//Copyright HeathenUK 2023, others' copyrights (Envenomator, Dean Belfield, etc.) unaffected.
;    2	
;    3	#include <stdio.h>
;    4	#include <stdlib.h>
;    5	#include <ctype.h>
;    6	#include <stdint.h>
;    7	#include <string.h>
;    8	#include <eZ80.h>
;    9	#include <defines.h>
;   10	#include "mos-interface.h"
;   11	#include "vdp.h"
;   12	
;   13	typedef struct {
;   14		
;   15		uint16_t bmp_width;
;   16		uint16_t bmp_height;
;   17		uint8_t  bmp_bitdepth;
;   18		
;   19	} bmp_info;
.BEGREC "NONAME6",5
.DEFINE "bmp_width"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "bmp_height"
.VALUE 2
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "bmp_bitdepth"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME6"
;   20	
;   21	extern void write16bit(uint16_t w);
;   22	extern void write24bit(uint24_t w);
;   23	extern void write32bit(uint32_t w);
;   24	
;   25	void delay_secs(UINT16 ticks_end) { //1 sec ticks
_delay_secs:
.DEFINE "_delay_secs"

.VALUE _delay_secs

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "delay_secs",25,"_delay_secs"

.LINE 25

.DEFINE "ticks_end"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

.DEFINE "ticks"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;   26		
;   27		UINT32 ticks = 0;
.LINE 27

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
;   28		ticks_end *= 60;
.LINE 28

	LD.LIS	HL,60
	LD	BC,(IX+%6)
	CALL	__smulu
	LD	(IX+%6),L
	LD	(IX+%7),H
;   29		while(true) {
L_3:
.LINE 29

;   30			
;   31			waitvblank();
.LINE 31

	CALL	_waitvblank
;   32			ticks++;
.LINE 32

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;   33			if(ticks >= ticks_end) break;
.LINE 33

	LD	BC,(IX+%6)
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	C,L_3
;   34			
;   35		}
;   36		
;   37	}
.LINE 37

	LD	SP,IX
	POP	IX
	RET	


;**************************** _delay_secs ***************************
;Name                         Addr/Register   Size   Type
;_waitvblank                         IMPORT  -----   function
;ticks                                 IX-4      4   variable
;ticks_end                             IX+6      2   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "delay_secs",37,"_delay_secs"
;   38	
;   39	int min(int a, int b) {
_min:
.DEFINE "_min"

.VALUE _min

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "min",39,"_min"

.LINE 39

.DEFINE "a"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   40	    if (a > b)
.LINE 40

	LD	BC,(IX+%6)
	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JP	P,L__3
	JP	PE,L_6
	JR	L__4
L__3:
	JP	PO,L_6
L__4:
;   41	        return b;
.LINE 41

	LD	HL,(IX+%9)
	JR	L_7
L_6:
;   42	    return a;
.LINE 42

	LD	HL,(IX+%6)
;   43	}
L_7:
.LINE 43

	LD	SP,IX
	POP	IX
	RET	


;**************************** _min ***************************
;Name                         Addr/Register   Size   Type
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "min",43,"_min"
;   44	
;   45	int max(int a, int b) {
_max:
.DEFINE "_max"

.VALUE _max

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "max",45,"_max"

.LINE 45

.DEFINE "a"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   46	    if (a > b)
.LINE 46

	LD	BC,(IX+%6)
	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JP	P,L__7
	JP	PE,L_9
	JR	L__8
L__7:
	JP	PO,L_9
L__8:
;   47	        return a;
.LINE 47

	LD	HL,(IX+%6)
	JR	L_10
L_9:
;   48	    return b;
.LINE 48

	LD	HL,(IX+%9)
;   49	}
L_10:
.LINE 49

	LD	SP,IX
	POP	IX
	RET	


;**************************** _max ***************************
;Name                         Addr/Register   Size   Type
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "max",49,"_max"
;   50	
;   51	void flip(uint32_t * framebuffer, int width, int height) {
_flip:
.DEFINE "_flip"

.VALUE _flip

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "flip",51,"_flip"

.LINE 51

.DEFINE "framebuffer"

.CLASS 65

.VALUE 6

.TYPE 47

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE 12

.TYPE 4

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "row_buffer"

.CLASS 65

.VALUE -5

.TYPE 47

.ENDEF

.DEFINE "row_size"

.CLASS 65

.VALUE -8

.TYPE 4

.ENDEF

.DEFINE "top_row"

.CLASS 65

.VALUE -11

.TYPE 47

.ENDEF

.DEFINE "bottom_row"

.CLASS 65

.VALUE -14

.TYPE 47

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF1
	LD	SP,HL
;   52	    uint16_t y;
;   53	    uint32_t * row_buffer = (uint32_t * ) malloc(sizeof(uint32_t) * width);
.LINE 53

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	(IX+%FFFFFFF1),A
	CALL	_malloc
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	LD	(IX+%FFFFFFFB),HL
;   54	    int row_size = width * sizeof(uint32_t);
.LINE 54

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	(IX+%FFFFFFF8),HL
;   55	
;   56	    for (y = 0; y < height / 2; y++) {
.LINE 56

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_14
L_12:
;   57	        uint32_t * top_row = framebuffer + y * width;
.LINE 57

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF5),HL
;   58	        uint32_t * bottom_row = framebuffer + (height - y - 1) * width;
.LINE 58

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	DEC	HL
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF2),HL
;   59	
;   60	        memcpy(row_buffer, top_row, row_size);
.LINE 60

	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	LD	(IX+%FFFFFFF1),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	POP	BC
	POP	BC
;   61	        memcpy(top_row, bottom_row, row_size);
.LINE 61

	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF2)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	(IX+%FFFFFFF1),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	POP	BC
	POP	BC
;   62	        memcpy(bottom_row, row_buffer, row_size);
.LINE 62

	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF2)
	PUSH	BC
	LD	(IX+%FFFFFFF1),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	POP	BC
	POP	BC
	LD	HL,(IX+%FFFFFFFE)
	INC	HL
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;   63	    }
L_14:
.LINE 63

	LD	BC,2
	LD	HL,(IX+%C)
	CALL	__idivs
	LD	DE,HL
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	OR	A,A
	SBC	HL,DE
	JP	M,L__11
	JP	PE,L_12
	JR	L__12
L__11:
	JP	PO,L_12
L__12:
;   64	
;   65	    free(row_buffer);
.LINE 65

	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	CALL	_free
	POP	BC
;   66	}
.LINE 66

	LD	SP,IX
	POP	IX
	RET	


;**************************** _flip ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_memcpy                             IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;bottom_row                           IX-14      3   variable
;top_row                              IX-11      3   variable
;row_size                              IX-8      3   variable
;row_buffer                            IX-5      3   variable
;y                                     IX-2      2   variable
;height                               IX+12      3   parameter
;width                                 IX+9      3   parameter
;framebuffer                           IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "flip",66,"_flip"
;   67	
;   68	void twiddle_buffer(char* buffer, int width, int height) {
_twiddle_buffer:
.DEFINE "_twiddle_buffer"

.VALUE _twiddle_buffer

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "twiddle_buffer",68,"_twiddle_buffer"

.LINE 68

.DEFINE "buffer"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE 12

.TYPE 4

.ENDEF

.DEFINE "col"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "tempRow"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "oppositeRowPtr"

.CLASS 65

.VALUE -9

.TYPE 34

.ENDEF

.DEFINE "rowPtr"

.CLASS 65

.VALUE -12

.TYPE 34

.ENDEF

.DEFINE "row"

.CLASS 65

.VALUE -15

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE4
	LD	SP,HL
;   69	    int row, col;
;   70	    char* rowPtr;
;   71		char* oppositeRowPtr;
;   72		char* tempRow = (char*)malloc(width * 4);
.LINE 72

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	(IX+%FFFFFFE4),A
	CALL	_malloc
	LD	A,(IX+%FFFFFFE4)
	POP	BC
	LD	(IX+%FFFFFFFA),HL
;   73	
;   74	    //Iterate over each row
;   75	    for (row = 0; row < height / 2; row++) {
.LINE 75

	LD	BC,0
	LD	(IX+%FFFFFFF1),BC
	JR	L_24
L_22:
;   76	        rowPtr = buffer + row * width * 4;
.LINE 76

	LD	HL,(IX+%FFFFFFF1)
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF4),HL
;   77	        oppositeRowPtr = buffer + (height - row - 1) * width * 4;
.LINE 77

	LD	BC,(IX+%FFFFFFF1)
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	DEC	HL
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF7),HL
;   78	
;   79	        //Swap bytes within each row (BGRA to RGBA)
;   80	        for (col = 0; col < width; col++) {
.LINE 80

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_21
L_19:
;   81	            tempRow[col * 4] = oppositeRowPtr[col * 4 + 2]; // R
.LINE 81

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,(IX+%FFFFFFF7)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	LD	A,(IY+%2)
	LD	(HL),A
;   82	            tempRow[col * 4 + 1] = oppositeRowPtr[col * 4 + 1]; // G
.LINE 82

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,DE
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	INC	HL
	LD	A,(IY+%1)
	LD	(HL),A
;   83	            tempRow[col * 4 + 2] = oppositeRowPtr[col * 4]; // B
.LINE 83

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	INC	HL
	INC	HL
	LD	A,(IY)
	LD	(HL),A
;   84	            tempRow[col * 4 + 3] = oppositeRowPtr[col * 4 + 3]; // A
.LINE 84

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	IY,HL
	LD	(IX+%FFFFFFEE),HL	; spill
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFEB),HL	; spill
	LD	BC,DE
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFEB)	; unspill
	LD	A,(HL)
	LD	(IY+%3),A
;   85	
;   86	            oppositeRowPtr[col * 4] = rowPtr[col * 4 + 2]; // R
.LINE 86

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,DE
	LD	A,(IY+%2)
	LD	(HL),A
;   87	            oppositeRowPtr[col * 4 + 1] = rowPtr[col * 4 + 1]; // G
.LINE 87

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,DE
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	INC	HL
	LD	A,(IY+%1)
	LD	(HL),A
;   88	            oppositeRowPtr[col * 4 + 2] = rowPtr[col * 4]; // B
.LINE 88

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,DE
	INC	HL
	INC	HL
	LD	A,(IY)
	LD	(HL),A
;   89	            oppositeRowPtr[col * 4 + 3] = rowPtr[col * 4 + 3]; // A
.LINE 89

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	IY,HL
	LD	(IX+%FFFFFFEE),HL	; spill
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFE8),HL	; spill
	LD	BC,DE
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFE8)	; unspill
	LD	A,(HL)
	LD	(IY+%3),A
;   90	
;   91	            rowPtr[col * 4] = tempRow[col * 4]; // R
.LINE 91

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	LD	A,(IY)
	LD	(HL),A
;   92	            rowPtr[col * 4 + 1] = tempRow[col * 4 + 1]; // G
.LINE 92

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,DE
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	INC	HL
	LD	A,(IY+%1)
	LD	(HL),A
;   93	            rowPtr[col * 4 + 2] = tempRow[col * 4 + 2]; // B
.LINE 93

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	INC	HL
	INC	HL
	LD	A,(IY+%2)
	LD	(HL),A
;   94	            rowPtr[col * 4 + 3] = tempRow[col * 4 + 3]; // A
.LINE 94

	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	IY,HL
	LD	(IX+%FFFFFFEE),HL	; spill
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFE5),HL	; spill
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFE5)	; unspill
	LD	A,(HL)
	LD	(IY+%3),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;   95	        }
L_21:
.LINE 95

	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JP	M,L__16
	JP	PE,L_19
	JR	L__17
L__16:
	JP	PO,L_19
L__17:
	LD	BC,(IX+%FFFFFFF1)
	INC	BC
	LD	(IX+%FFFFFFF1),BC
;   96	    }
L_24:
.LINE 96

	LD	BC,2
	LD	HL,(IX+%C)
	CALL	__idivs
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF1)
	OR	A,A
	SBC	HL,BC
	JP	M,L__18
	JP	PE,L_22
	JR	L__19
L__18:
	JP	PO,L_22
L__19:
;   97		free(tempRow);
.LINE 97

	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_free
	POP	BC
;   98	}
.LINE 98

	LD	SP,IX
	POP	IX
	RET	


;**************************** _twiddle_buffer ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;row                                  IX-15      3   variable
;rowPtr                               IX-12      3   variable
;oppositeRowPtr                        IX-9      3   variable
;tempRow                               IX-6      3   variable
;col                                   IX-3      3   variable
;height                               IX+12      3   parameter
;width                                 IX+9      3   parameter
;buffer                                IX+6      3   parameter


; Stack Frame Size: 43 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "twiddle_buffer",98,"_twiddle_buffer"
;   99	
;  100	void reorder(char *arr, uint16_t length, BOOL alpha) {
_reorder:
.DEFINE "_reorder"

.VALUE _reorder

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "reorder",100,"_reorder"

.LINE 100

.DEFINE "arr"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "length"

.CLASS 65

.VALUE 9

.TYPE 13

.ENDEF

.DEFINE "alpha"

.CLASS 65

.VALUE 12

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "temp"

.CLASS 65

.VALUE -3

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
;  101	    uint16_t i;
;  102		for (i = 0; i < length; i += 4) {
.LINE 102

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_31
L_29:
;  103	        if (i + 2 < length) {
.LINE 103

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	DE,HL
	INC	DE
	INC	DE
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JP	P,L__24
	JP	PE,L_30
	JR	L__25
L__24:
	JP	PO,L_30
L__25:
;  104	            uint8_t temp = arr[i];
.LINE 104

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF7),HL
	LD	A,(HL)
	LD	(IX+%FFFFFFFD),A
;  105	            arr[i] = arr[i + 2];
.LINE 105

	LD	IY,(IX+%FFFFFFF7)
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	A,(IY+%2)
	LD	(HL),A
;  106	            arr[i + 2] = temp;
.LINE 106

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFFA),HL
	LD	IY,(IX+%FFFFFFFA)
	LEA	HL,IY+%2
	LD	A,(IX+%FFFFFFFD)
	LD	(HL),A
;  107				if (alpha == false) arr[i + 3] = 0xFF;
.LINE 107

	LD	A,(IX+%C)
	OR	A,A
	JR	NZ,L_30
	LD	IY,(IX+%FFFFFFFA)
	LEA	HL,IY+%3
	LD	(HL),%FF
;  108	        }
;  109	    }
L_30:
.LINE 109

	LD	IY,(IX+%FFFFFFFE)
	LEA	HL,IY+%4
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
L_31:
	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_29
;  110	}
.LINE 110

	LD	SP,IX
	POP	IX
	RET	


;**************************** _reorder ***************************
;Name                         Addr/Register   Size   Type
;G_0                                   IX-6      3   variable
;temp                                  IX-3      1   variable
;i                                     IX-2      2   variable
;alpha                                IX+12      1   parameter
;length                                IX+9      2   parameter
;arr                                   IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "reorder",110,"_reorder"
;  111	
;  112	void reorder_and_insert(char *arr, uint16_t length, char **new_arr, uint16_t *new_length, char insert_value) {
_reorder_and_insert:
.DEFINE "_reorder_and_insert"

.VALUE _reorder_and_insert

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "reorder_and_insert",112,"_reorder_and_insert"

.LINE 112

.DEFINE "arr"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "length"

.CLASS 65

.VALUE 9

.TYPE 13

.ENDEF

.DEFINE "new_arr"

.CLASS 65

.VALUE 12

.TYPE 290

.ENDEF

.DEFINE "new_length"

.CLASS 65

.VALUE 15

.TYPE 45

.ENDEF

.DEFINE "insert_value"

.CLASS 65

.VALUE 18

.TYPE 2

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "j"

.CLASS 65

.VALUE -4

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFED
	LD	SP,HL
;  113	
;  114		uint16_t i, j = 0;
.LINE 114

	LD	(IX+%FFFFFFFC),%0
	LD	(IX+%FFFFFFFD),%0
;  115	    *new_length = (length / 3) * 4 + (length % 3);
.LINE 115

	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,3
	CALL	__idivs
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,3
	CALL	__irems
	ADD	HL,DE
	LD	BC,HL
	LD	HL,(IX+%F)
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  116	    *new_arr = (char *) malloc(*new_length * sizeof(char));
.LINE 116

	LD	HL,(IX+%F)
	LD	BC,(HL)
	CALL	__stoiu
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	IY,(IX+%C)
	LD	(IY),HL
;  117	
;  118	    for (i = 0; i < length; i += 3) {
.LINE 118

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_43
L_41:
;  119	        
;  120	        (*new_arr)[j] = (i + 2 < length) ? arr[i + 2] : 0;
.LINE 120

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	DE,HL
	INC	DE
	INC	DE
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JP	P,L_35
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	(IX+%FFFFFFF9),HL
	JR	L_36
L_35:
	LD	BC,0
	LD	(IX+%FFFFFFF9),BC
L_36:
	LD	IY,(IX+%C)
	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	BC,(IY)
	ADD	HL,BC
	LD	(IX+%FFFFFFF3),HL
	LD	A,(IX+%FFFFFFF9)
	LD	HL,(IX+%FFFFFFF3)
	LD	(HL),A
;  121	        (*new_arr)[j + 1] = (i + 1 < length) ? arr[i + 1] : 0;
.LINE 121

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	DE,HL
	INC	DE
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JP	P,L__30
	JP	PE,L_39
	JR	L__31
L__30:
	JP	PO,L_39
L__31:
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	INC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	(IX+%FFFFFFF6),HL
	JR	L_40
L_39:
	LD	BC,0
	LD	(IX+%FFFFFFF6),BC
L_40:
	LD	A,(IX+%FFFFFFF6)
	LD	HL,(IX+%FFFFFFF3)
	INC	HL
	LD	(HL),A
;  122	        (*new_arr)[j + 2] = arr[i];
.LINE 122

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%C)
	LD	(IX+%FFFFFFED),HL	; spill
	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	(IX+%FFFFFFF0),HL	; spill
	LD	HL,(IX+%FFFFFFED)	; unspill
	LD	BC,(HL)
	LD	HL,(IX+%FFFFFFF0)	; unspill
	ADD	HL,BC
	INC	HL
	INC	HL
	LD	A,(IY)
	LD	(HL),A
;  123	        
;  124	        (*new_arr)[j + 3] = 0xFF;
.LINE 124

	LD	IY,(IX+%C)
	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	BC,(IY)
	ADD	HL,BC
	LD	IY,HL
	LEA	HL,IY+%3
	LD	(HL),%FF
;  125	
;  126	        j += 4;
.LINE 126

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%4
	LD	(IX+%FFFFFFFC),L
	LD	(IX+%FFFFFFFD),H
	LD	IY,(IX+%FFFFFFFE)
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  127	    }
L_43:
.LINE 127

	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_41
;  128		free(new_arr);
.LINE 128

	LD	BC,(IX+%C)
	PUSH	BC
	CALL	_free
	POP	BC
;  129	}
.LINE 129

	LD	SP,IX
	POP	IX
	RET	


;**************************** _reorder_and_insert ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;G_1                                  IX-13      3   variable
;temp37                               IX-10      3   variable
;temp33                                IX-7      3   variable
;j                                     IX-4      2   variable
;i                                     IX-2      2   variable
;insert_value                         IX+18      1   parameter
;new_length                           IX+15      3   parameter
;new_arr                              IX+12      3   parameter
;length                                IX+9      2   parameter
;arr                                   IX+6      3   parameter


; Stack Frame Size: 40 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "reorder_and_insert",129,"_reorder_and_insert"
;  130	
;  131	bmp_info load_bmp_big(const char * filename, UINT8 slot) { //Uses 64x64x4 chunks
_load_bmp_big:
.DEFINE "_load_bmp_big"

.VALUE _load_bmp_big

.CLASS 2

.TAG "NONAME6"

.TYPE 72

.ENDEF

.BEGFUNC "load_bmp_big",131,"_load_bmp_big"

.LINE 131

.DEFINE "filename"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "slot"

.CLASS 65

.VALUE 12

.TYPE 12

.ENDEF

.DEFINE "file"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -5

.TYPE 5

.ENDEF

.DEFINE "bit_depth"

.CLASS 65

.VALUE -9

.TYPE 5

.ENDEF

.DEFINE "src"

.CLASS 65

.VALUE -12

.TYPE 34

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE -16

.TYPE 5

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE -20

.TYPE 5

.ENDEF

.DEFINE "return_info"

.CLASS 65

.VALUE -29

.TAG "NONAME6"

.TYPE 8

.ENDEF

.DEFINE "row_padding"

.CLASS 65

.VALUE -33

.TYPE 5

.ENDEF

.DEFINE "index"

.CLASS 65

.VALUE -38

.TYPE 12

.ENDEF

.DEFINE "color_table_size"

.CLASS 65

.VALUE -42

.TYPE 15

.ENDEF

.DEFINE "fo"

.CLASS 65

.VALUE -45

.TAG "NONAME5"

.TYPE 40

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -49

.TYPE 5

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -50

.TYPE 12

.ENDEF

.DEFINE "g"

.CLASS 65

.VALUE -51

.TYPE 12

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -52

.TYPE 12

.ENDEF

.DEFINE "non_pad_row"

.CLASS 65

.VALUE -55

.TYPE 4

.ENDEF

.DEFINE "new_row_size"

.CLASS 65

.VALUE -57

.TYPE 13

.ENDEF

.DEFINE "image_start"

.CLASS 65

.VALUE -61

.TYPE 5

.ENDEF

.DEFINE "row_24bpp"

.CLASS 65

.VALUE -64

.TYPE 34

.ENDEF

.DEFINE "image_buffer"

.CLASS 65

.VALUE -67

.TYPE 34

.ENDEF

.DEFINE "biSize"

.CLASS 65

.VALUE -71

.TYPE 15

.ENDEF

.DEFINE "alphamask"

.CLASS 65

.VALUE -75

.TYPE 15

.ENDEF

.DEFINE "non_pad_row"

.CLASS 65

.VALUE -78

.TYPE 4

.ENDEF

.DEFINE "non_pad_row"

.CLASS 65

.VALUE -81

.TYPE 4

.ENDEF

.DEFINE "small_header"

.CLASS 65

.VALUE -99

.DIM 18

.TYPE 98

.ENDEF

.DEFINE "header"

.CLASS 65

.VALUE -227

.DIM 128

.TYPE 98

.ENDEF

.DEFINE "color_table"

.CLASS 65

.VALUE -1251

.DIM 1024

.TYPE 98

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-1270
	ADD	HL,SP
	LD	SP,HL
;  132	
;  133	    int32_t image_start, width, height, bit_depth, row_padding = 0, y, x, i;
;  134		char* row_24bpp;
;  135	    uint8_t pixel[4], file, r, g, b, index;
;  136	    char header[128], color_table[1024];
;  137		char small_header[18];
;  138	    uint32_t pixel_value, color_table_size, bytes_per_row, alphamask;
;  139	    uint32_t biSize;
;  140	    FIL * fo;
;  141		bmp_info return_info;
;  142	
;  143	    char * src;
;  144	    char * image_buffer;
;  145		
;  146		//if (game.vgm_file != NULL) parse_vgm_file(game.vgm_file);
;  147		
;  148		return_info.bmp_width = 0;
.LINE 148

	LD	(IX+%FFFFFFE3),%0
	LD	(IX+%FFFFFFE4),%0
;  149		return_info.bmp_height = 0;
.LINE 149

	LD	(IX+%FFFFFFE5),%0
	LD	(IX+%FFFFFFE6),%0
;  150		return_info.bmp_bitdepth = 0;	
.LINE 150

	LD	(IX+%FFFFFFE7),%0
;  151	
;  152	    file = mos_fopen(filename, fa_read);
.LINE 152

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  153	    if (!file) {
.LINE 153

	OR	A,A
	JR	NZ,L_47
;  154	        printf("Error: could not open %s.\r\n", filename);
.LINE 154

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__34
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__35
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  155	        return return_info;
.LINE 155

	LEA	HL,IX+%6
	LD	DE,(HL)
	LEA	HL,IX+%FFFFFFE3
	LD	BC,5
	LDIR	
	LD	HL,(IX+%6)
	JR	L_83
;  156	    }
L_47:
.LINE 156

;  157	    fo = (FIL * ) mos_getfil(file);
.LINE 157

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_getfil
	POP	BC
	LD	(IX+%FFFFFFD3),HL
;  158	
;  159	    mos_fread(file, small_header, 18);
.LINE 159

	LD	BC,18
	PUSH	BC
	PEA	IX+%FFFFFF9D
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  160		biSize = * (uint32_t * ) & small_header[14];
.LINE 160

	LEA	HL,IX+%FFFFFFAB
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFB9),BC
	LD	(IX+%FFFFFFBC),A
;  161		mos_flseek(file,0);
.LINE 161

	LD	BC,0
	PUSH	BC
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  162		mos_fread(file, header, biSize);
.LINE 162

	LD	BC,(IX+%FFFFFFB9)
	PUSH	BC
	LD	HL,IX
	LD	BC,-227
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  163	
;  164		image_start = * (uint32_t * ) & header[10];
.LINE 164

	LD	IY,IX
	LD	BC,-227
	ADD	IY,BC
	LEA	HL,IY+%A
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFC3),BC
	LD	(IX+%FFFFFFC6),A
;  165	    biSize = * (uint32_t * ) & header[14];
.LINE 165

	LD	IY,IX
	LD	BC,-227
	ADD	IY,BC
	LEA	HL,IY+%E
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFB9),BC
	LD	(IX+%FFFFFFBC),A
;  166	    width = * (INT32 * ) & header[18];
.LINE 166

	LD	IY,IX
	LD	BC,-227
	ADD	IY,BC
	LEA	HL,IY+%12
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFF0),BC
	LD	(IX+%FFFFFFF3),A
;  167	    height = * (INT32 * ) & header[22];
.LINE 167

	LD	IY,IX
	LD	BC,-227
	ADD	IY,BC
	LEA	HL,IY+%16
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFEC),BC
	LD	(IX+%FFFFFFEF),A
;  168	    bit_depth = * (uint16_t * ) & header[28];
.LINE 168

	LD	IY,IX
	LD	BC,-227
	ADD	IY,BC
	LEA	HL,IY+%1C
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	(IX+%FFFFFFF7),BC
	LD	(IX+%FFFFFFFA),A
;  169	    color_table_size = * (uint32_t * ) & header[46];
.LINE 169

	LD	IY,IX
	LD	DE,-227
	ADD	IY,DE
	LEA	HL,IY+%2E
	LD	DE,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFD6),DE
	LD	(IX+%FFFFFFD9),A
;  170		alphamask =  * (uint32_t * ) & header[52];
.LINE 170

	LD	IY,IX
	LD	DE,-227
	ADD	IY,DE
	LEA	HL,IY+%34
	LD	DE,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFB5),DE
	LD	(IX+%FFFFFFB8),A
;  171		
;  172	    image_buffer = (char * ) malloc(width * bit_depth / 8);
.LINE 172

	LD	HL,(IX+%FFFFFFF0)
	LD	E,(IX+%FFFFFFF3)
	LD	A,(IX+%FFFFFFFA)
	CALL	__lmuls
	LD	BC,8
	XOR	A,A
	CALL	__ldivs
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFBD),HL
;  173	
;  174	    if (color_table_size == 0 && bit_depth == 8) {
.LINE 174

	LD	HL,(IX+%FFFFFFD6)
	LD	E,(IX+%FFFFFFD9)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_51
	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,8
	XOR	A,A
	CALL	__lcmps
	JR	NZ,L_51
;  175	        color_table_size = 256;
.LINE 175

	LD	BC,256
	XOR	A,A
	LD	(IX+%FFFFFFD6),BC
	LD	(IX+%FFFFFFD9),A
;  176	    }
L_51:
.LINE 176

;  177	
;  178	    if (color_table_size > 0) mos_fread(file, color_table, color_table_size * 4);
.LINE 178

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(IX+%FFFFFFD6)
	LD	A,(IX+%FFFFFFD9)
	CALL	__lcmpu
	JR	NC,L_55
	LD	HL,(IX+%FFFFFFD6)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	HL,IX
	LD	BC,-1251
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
L_55:
;  179		
;  180	    if ((bit_depth != 32) && (bit_depth != 24) && (bit_depth != 8)) {
.LINE 180

	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,32
	XOR	A,A
	CALL	__lcmps
	JR	Z,L_56
	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,24
	XOR	A,A
	CALL	__lcmps
	JR	Z,L_56
	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,8
	XOR	A,A
	CALL	__lcmps
	JR	Z,L_56
;  181	        printf("Error: unsupported bit depth (not 8, 24 or 32-bit).\n");
.LINE 181

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__42
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  182	        mos_fclose(file);
.LINE 182

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  183	        return return_info;
.LINE 183

	LEA	HL,IX+%6
	LD	DE,(HL)
	LEA	HL,IX+%FFFFFFE3
	LD	BC,5
	LDIR	
	LD	HL,(IX+%6)
	JR	L_83
;  184	    }
L_56:
.LINE 184

;  185		
;  186	    row_padding = (4 - (width * (bit_depth / 8)) % 4) % 4;
.LINE 186

	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,8
	XOR	A,A
	CALL	__ldivs
	LD	BC,(IX+%FFFFFFF0)
	LD	A,(IX+%FFFFFFF3)
	CALL	__lmuls
	LD	BC,4
	XOR	A,A
	CALL	__lrems
	LD	A,E
	LD	BC,HL
	LD	HL,4
	LD	E,%0
	CALL	__lsub
	LD	BC,4
	XOR	A,A
	CALL	__lrems
	LD	(IX+%FFFFFFDF),HL
	LD	(IX+%FFFFFFE2),E
;  187	
;  188		//clear_buffer(slot);
;  189		
;  190	    vdp_bitmapSelect(slot);
.LINE 190

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_vdp_bitmapSelect
	POP	BC
;  191	    putch(23); // vdu_sys
.LINE 191

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  192	    putch(27); // sprite command
.LINE 192

	LD	BC,27
	PUSH	BC
	CALL	_putch
	POP	BC
;  193	    putch(1); // send data to selected bitmap
.LINE 193

	LD	BC,1
	PUSH	BC
	CALL	_putch
	POP	BC
;  194	
;  195	    write16bit(width);
.LINE 195

	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  196	    write16bit(height);
.LINE 196

	LD	BC,(IX+%FFFFFFEC)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  197		
;  198	    if (bit_depth == 8) {
.LINE 198

	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,8
	XOR	A,A
	CALL	__lcmps
	JR	NZ,L_81
;  199			uint8_t a = 0xFF;
;  200			int non_pad_row = width * bit_depth / 8;
.LINE 200

	LD	HL,(IX+%FFFFFFF0)
	LD	E,(IX+%FFFFFFF3)
	LD	BC,(IX+%FFFFFFF7)
	LD	A,(IX+%FFFFFFFA)
	CALL	__lmuls
	LD	BC,8
	XOR	A,A
	CALL	__ldivs
	LD	(IX+%FFFFFFC9),HL
;  201			mos_flseek(file, image_start + ((height - 1) * (non_pad_row + row_padding)));
.LINE 201

	LD	BC,HL
	CALL	__itol
	LD	HL,(IX+%FFFFFFDF)
	LD	E,(IX+%FFFFFFE2)
	CALL	__ladd
	LD	A,E
	LD	IY,-1267	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),A
	LD	BC,-1270	; spill
	CALL	__istix
	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	A,E
	LD	BC,HL
	PUSH	BC
	LD	IY,-1255	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),A
	LD	IY,-1267	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	LD	E,A
	PUSH	BC
	LD	IY,-1255	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	LD	HL,BC
	LD	BC,-1259	; spill
	CALL	__istix
	LD	BC,-1270	; unspill
	CALL	__ildix
	LD	BC,HL
	LD	HL,BC
	LD	BC,-1259	; unspill
	PUSH	HL
	CALL	__ildix
	LD	BC,HL
	POP	HL
	CALL	__lmulu
	LD	BC,(IX+%FFFFFFC3)
	LD	A,(IX+%FFFFFFC6)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  202			
;  203	        for (y = height - 1; y >= 0; y--) {
.LINE 203

	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
	JR	L_65
L_63:
;  204	            for (x = 0; x < width; x++) {
.LINE 204

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFCF),BC
	LD	(IX+%FFFFFFD2),A
	JR	L_61
L_59:
;  205	
;  206	                index = (char) mos_fgetc(file);
.LINE 206

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fgetc
	POP	BC
	LD	(IX+%FFFFFFDA),A
;  207	                b = color_table[index * 4];
.LINE 207

	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,IX
	LD	DE,-1251
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,-1254
	LD	BC,IX
	ADD	IY,BC
	LD	(IY),HL
	LD	HL,-1254
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	A,(HL)
	LD	(IX+%FFFFFFCC),A
;  208	                g = color_table[index * 4 + 1];
.LINE 208

	LD	HL,-1254
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFCD),A
;  209	                r = color_table[index * 4 + 2];
.LINE 209

	LD	HL,-1254
	LD	BC,IX
	ADD	HL,BC
	LD	IY,(HL)
	LEA	HL,IY+%2
	LD	A,(HL)
	LD	(IX+%FFFFFFCE),A
;  210					
;  211					putch(r);
.LINE 211

	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;  212					putch(g);
.LINE 212

	LD	A,(IX+%FFFFFFCD)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;  213					putch(b);
.LINE 213

	LD	A,(IX+%FFFFFFCC)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;  214					putch(0xFF);
.LINE 214

	LD	BC,255
	PUSH	BC
	CALL	_putch
	POP	BC
	LD	HL,(IX+%FFFFFFCF)
	LD	E,(IX+%FFFFFFD2)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFCF),HL
	LD	(IX+%FFFFFFD2),E
;  215					
;  216	
;  217	            }
L_61:
.LINE 217

	LD	HL,(IX+%FFFFFFCF)
	LD	E,(IX+%FFFFFFD2)
	LD	BC,(IX+%FFFFFFF0)
	LD	A,(IX+%FFFFFFF3)
	CALL	__lcmps
	JP	M,L_59
;  218				
;  219				//add_stream_to_buffer(slot,row_rgba2222,width);
;  220				mos_flseek(file, fo -> fptr - ((non_pad_row * 2) + row_padding));
.LINE 220

	LD	HL,(IX+%FFFFFFC9)
	ADD	HL,HL
	LD	BC,HL
	CALL	__itol
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+%FFFFFFDF)
	LD	A,(IX+%FFFFFFE2)
	CALL	__ladd
	LD	A,E
	LD	BC,HL
	LD	IY,(IX+%FFFFFFD3)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
;  221	            // for (i = 0; i < row_padding; i++) {
;  222	                // mos_fgetc(file);
;  223	            // }
;  224	
;  225	        }
L_65:
.LINE 225

	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,0
	XOR	A,A
	CALL	__lcmps
	JP	P,L__51
	JP	PE,L_63
	JR	L__52
L__51:
	JP	PO,L_63
L__52:
	JR	L_82
;  226	
;  227	    } else if (bit_depth == 32) {
L_81:
.LINE 227

	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,32
	XOR	A,A
	CALL	__lcmps
	JR	NZ,L_79
;  228	        
;  229			int non_pad_row = width * bit_depth / 8;
.LINE 229

	LD	HL,(IX+%FFFFFFF0)
	LD	E,(IX+%FFFFFFF3)
	LD	BC,(IX+%FFFFFFF7)
	LD	A,(IX+%FFFFFFFA)
	CALL	__lmuls
	LD	BC,8
	XOR	A,A
	CALL	__ldivs
	LD	(IX+%FFFFFFE8),HL
	LD	(IX+%FFFFFFEB),E
	LD	(IX+%FFFFFFAF),HL
;  230	        src = (char * ) malloc(width * bit_depth / 8);
.LINE 230

	LD	BC,HL
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFF4),HL
;  231			mos_flseek(file, image_start + ((height - 1) * (non_pad_row + row_padding)));
.LINE 231

	LD	BC,(IX+%FFFFFFE8)
	CALL	__itol
	LD	HL,(IX+%FFFFFFDF)
	LD	E,(IX+%FFFFFFE2)
	CALL	__ladd
	LD	A,E
	LD	IY,-1263	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),A
	LD	BC,-1266	; spill
	CALL	__istix
	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	A,E
	LD	BC,HL
	PUSH	BC
	LD	IY,-1255	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),A
	LD	IY,-1263	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	LD	E,A
	PUSH	BC
	LD	IY,-1255	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	LD	HL,BC
	LD	BC,-1259	; spill
	CALL	__istix
	LD	BC,-1266	; unspill
	CALL	__ildix
	LD	BC,HL
	LD	HL,BC
	LD	BC,-1259	; unspill
	PUSH	HL
	CALL	__ildix
	LD	BC,HL
	POP	HL
	CALL	__lmulu
	LD	BC,(IX+%FFFFFFC3)
	LD	A,(IX+%FFFFFFC6)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  232	
;  233	        for (y = height - 1; y >= 0; y--) {
.LINE 233

	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
	JR	L_72
L_70:
;  234	
;  235	            mos_fread(file, src, non_pad_row);
.LINE 235

	LD	BC,(IX+%FFFFFFE8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  236				if (alphamask == 0) reorder(src, non_pad_row, false);
.LINE 236

	LD	HL,(IX+%FFFFFFB5)
	LD	E,(IX+%FFFFFFB8)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_68
	PUSH	BC
	LD	BC,(IX+%FFFFFFE8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_reorder
	POP	BC
	POP	BC
	POP	BC
;  237				else reorder(src, non_pad_row, true);
.LINE 237

	JR	L_69
L_68:
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%FFFFFFE8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_reorder
	POP	BC
	POP	BC
	POP	BC
L_69:
;  238	            mos_puts(src, non_pad_row, 0);
.LINE 238

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%FFFFFFE8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_mos_puts
	POP	BC
	POP	BC
	POP	BC
;  239				//add_stream_to_buffer(slot,src,non_pad_row);
;  240	            mos_flseek(file, fo -> fptr - ((non_pad_row * 2) + row_padding));
.LINE 240

	LD	HL,(IX+%FFFFFFE8)
	ADD	HL,HL
	LD	BC,HL
	CALL	__itol
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+%FFFFFFDF)
	LD	A,(IX+%FFFFFFE2)
	CALL	__ladd
	LD	A,E
	LD	BC,HL
	LD	IY,(IX+%FFFFFFD3)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  241				free(src);			
.LINE 241

	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
;  242	
;  243	        }
L_72:
.LINE 243

	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,0
	XOR	A,A
	CALL	__lcmps
	JP	P,L__53
	JP	PE,L_70
	JR	L__54
L__53:
	JP	PO,L_70
L__54:
	JR	L_82
;  244	
;  245	    } else if (bit_depth == 24) {
L_79:
.LINE 245

	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,24
	XOR	A,A
	CALL	__lcmps
	JR	NZ,L_82
;  246			
;  247			uint16_t new_row_size;
;  248			int non_pad_row = width * bit_depth / 8;
.LINE 248

	LD	HL,(IX+%FFFFFFF0)
	LD	E,(IX+%FFFFFFF3)
	LD	BC,(IX+%FFFFFFF7)
	LD	A,(IX+%FFFFFFFA)
	CALL	__lmuls
	LD	BC,8
	XOR	A,A
	CALL	__ldivs
	LD	(IX+%FFFFFFDB),HL
	LD	(IX+%FFFFFFDE),E
	LD	(IX+%FFFFFFB2),HL
;  249			
;  250	        src = (char * ) malloc(width * bit_depth / 8);
.LINE 250

	LD	BC,HL
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFF4),HL
;  251			mos_flseek(file, image_start + ((height - 1) * (non_pad_row + row_padding)));
.LINE 251

	LD	BC,(IX+%FFFFFFDB)
	CALL	__itol
	LD	HL,(IX+%FFFFFFDF)
	LD	E,(IX+%FFFFFFE2)
	CALL	__ladd
	LD	A,E
	LD	IY,-1256	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),A
	LD	BC,-1262	; spill
	CALL	__istix
	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	A,E
	LD	BC,HL
	PUSH	BC
	LD	IY,-1255	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),A
	LD	IY,-1256	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	LD	E,A
	PUSH	BC
	LD	IY,-1255	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	LD	HL,BC
	LD	BC,-1259	; spill
	CALL	__istix
	LD	BC,-1262	; unspill
	CALL	__ildix
	LD	BC,HL
	LD	HL,BC
	LD	BC,-1259	; unspill
	PUSH	HL
	CALL	__ildix
	LD	BC,HL
	POP	HL
	CALL	__lmulu
	LD	BC,(IX+%FFFFFFC3)
	LD	A,(IX+%FFFFFFC6)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  252			
;  253	        for (y = height - 1; y >= 0; y--) {
.LINE 253

	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
	JR	L_76
L_74:
;  254	
;  255	            mos_fread(file, src, non_pad_row);
.LINE 255

	LD	BC,(IX+%FFFFFFDB)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  256				reorder_and_insert(src, non_pad_row, &row_24bpp, &new_row_size, 0xFF);
.LINE 256

	LD	BC,16777215
	PUSH	BC
	PEA	IX+%FFFFFFC7
	PEA	IX+%FFFFFFC0
	LD	BC,(IX+%FFFFFFDB)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_reorder_and_insert
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  257	            mos_puts(row_24bpp, new_row_size, 0);
.LINE 257

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%FFFFFFC7)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(IX+%FFFFFFC0)
	PUSH	BC
	CALL	_mos_puts
	POP	BC
	POP	BC
	POP	BC
;  258				//add_stream_to_buffer(slot,row_24bpp,new_row_size);
;  259	            mos_flseek(file, fo -> fptr - ((non_pad_row * 2) + row_padding));
.LINE 259

	LD	HL,(IX+%FFFFFFDB)
	ADD	HL,HL
	LD	BC,HL
	CALL	__itol
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+%FFFFFFDF)
	LD	A,(IX+%FFFFFFE2)
	CALL	__ladd
	LD	A,E
	LD	BC,HL
	LD	IY,(IX+%FFFFFFD3)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  260				free(row_24bpp);
.LINE 260

	LD	BC,(IX+%FFFFFFC0)
	PUSH	BC
	CALL	_free
	POP	BC
;  261				free(src);
.LINE 261

	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
;  262	
;  263	        }		
L_76:
.LINE 263

	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,0
	XOR	A,A
	CALL	__lcmps
	JP	P,L__55
	JP	PE,L_74
	JR	L__56
L__55:
	JP	PO,L_74
L__56:
;  264			
;  265		}
L_82:
.LINE 265

;  266	
;  267		//assign_buffer_to_bitmap(slot,0,width,height);
;  268		
;  269	    mos_fclose(file);
.LINE 269

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  270	    free(image_buffer);
.LINE 270

	LD	BC,(IX+%FFFFFFBD)
	PUSH	BC
	CALL	_free
	POP	BC
;  271	    //return width * height;
;  272		return_info.bmp_width = width;
.LINE 272

	LD	HL,(IX+%FFFFFFF0)
	LD	(IX+%FFFFFFE3),L
	LD	(IX+%FFFFFFE4),H
;  273		return_info.bmp_height = height;
.LINE 273

	LD	HL,(IX+%FFFFFFEC)
	LD	(IX+%FFFFFFE5),L
	LD	(IX+%FFFFFFE6),H
;  274		return_info.bmp_bitdepth = bit_depth;
.LINE 274

	LD	A,(IX+%FFFFFFF7)
	LD	(IX+%FFFFFFE7),A
;  275		return return_info;
.LINE 275

	LEA	HL,IX+%6
	LD	DE,(HL)
	LEA	HL,IX+%FFFFFFE3
	LD	BC,5
	LDIR	
	LD	HL,(IX+%6)
;  276	
;  277	}
L_83:
.LINE 277

	LD	SP,IX
	POP	IX
	RET	


;**************************** _load_bmp_big ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_mos_puts                           IMPORT  -----   function
;_mos_fgetc                          IMPORT  -----   function
;_write16bit                         IMPORT  -----   function
;_putch                              IMPORT  -----   function
;_vdp_bitmapSelect                   IMPORT  -----   function
;_mos_fclose                         IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;_mos_flseek                         IMPORT  -----   function
;_mos_fread                          IMPORT  -----   function
;_mos_getfil                         IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;color_table                        IX-1251   1024   variable
;header                              IX-227    128   variable
;small_header                         IX-99     18   variable
;non_pad_row                          IX-81      3   variable
;non_pad_row                          IX-78      3   variable
;alphamask                            IX-75      4   variable
;biSize                               IX-71      4   variable
;image_buffer                         IX-67      3   variable
;row_24bpp                            IX-64      3   variable
;image_start                          IX-61      4   variable
;new_row_size                         IX-57      2   variable
;non_pad_row                          IX-55      3   variable
;b                                    IX-52      1   variable
;g                                    IX-51      1   variable
;r                                    IX-50      1   variable
;x                                    IX-49      4   variable
;fo                                   IX-45      3   variable
;color_table_size                     IX-42      4   variable
;index                                IX-38      1   variable
;O_17                                 IX-37      4   variable
;row_padding                          IX-33      4   variable
;return_info                          IX-29      5   variable
;O_15                                 IX-24      4   variable
;height                               IX-20      4   variable
;width                                IX-16      4   variable
;src                                  IX-12      3   variable
;bit_depth                             IX-9      4   variable
;y                                     IX-5      4   variable
;file                                  IX-1      1   variable
;slot                                 IX+12      1   parameter
;filename                              IX+9      3   parameter


; Stack Frame Size: 1285 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "load_bmp_big",277,"_load_bmp_big"
	SEGMENT STRSECT
L__34:
	DB	"Error: could not open "
	DB	0
L__35:
	DB	"."
	DB	13,10,0
L__42:
	DB	"Error: unsupported bit depth (not 8, 24 or 32-bit)."
	DB	10,0
	SEGMENT CODE
;  278	
;  279	uint16_t strtou16(const char *str) {
_strtou16:
.DEFINE "_strtou16"

.VALUE _strtou16

.CLASS 2

.TYPE 77

.ENDEF

.BEGFUNC "strtou16",279,"_strtou16"

.LINE 279

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "result"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "digit"

.CLASS 65

.VALUE -4

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;  280	    uint16_t result = 0;
.LINE 280

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
;  281	    const uint16_t maxDiv10 = 6553;  // 65535 / 10
;  282	    const uint16_t maxMod10 = 5;     // 65535 % 10
;  283	
;  284	    while (*str == ' ' || *str == '\t' || *str == '\n') {
.LINE 284

	JR	L_87
L_88:
;  285	        str++;
.LINE 285

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  286	    }
L_87:
.LINE 286

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_88
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	Z,L_88
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	JR	Z,L_88
;  287	
;  288	    while (*str >= '0' && *str <= '9') {
.LINE 288

	JR	L_95
L_96:
;  289	        uint16_t digit = *str - '0';
.LINE 289

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	HL,IY+%FFFFFFD0
	LD	(IX+%FFFFFFFC),L
	LD	(IX+%FFFFFFFD),H
;  290	        if (result > maxDiv10 || (result == maxDiv10 && digit > maxMod10)) {
.LINE 290

	LD	BC,(IX+%FFFFFFFE)
	LD.LIS	HL,6553
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_92
	LD.LIS	BC,6553
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_93
	LD	BC,(IX+%FFFFFFFC)
	LD.LIS	HL,5
	OR	A,A
	SBC.SIS	HL,BC
	JR	NC,L_93
L_92:
;  291	            return 65535;
.LINE 291

	LD.LIS	HL,65535
	JR	L_99
;  292	        }
L_93:
.LINE 292

;  293	        result = result * 10 + digit;
.LINE 293

	LD.LIS	HL,10
	LD	BC,(IX+%FFFFFFFE)
	CALL	__smulu
	LD	BC,(IX+%FFFFFFFC)
	ADD.SIS	HL,BC
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  294	        str++;
.LINE 294

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  295	    }
L_95:
.LINE 295

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L__66
	JP	PE,L_98
	JR	L__67
L__66:
	JP	PO,L_98
L__67:
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L__68
	JP	PE,L_96
	JR	L__69
L__68:
	JP	PO,L_96
L__69:
L_98:
;  296	
;  297	    return result;
.LINE 297

	LD	HL,(IX+%FFFFFFFE)
;  298	}
L_99:
.LINE 298

	LD	SP,IX
	POP	IX
	RET	


;**************************** _strtou16 ***************************
;Name                         Addr/Register   Size   Type
;digit                                 IX-4      2   variable
;result                                IX-2      2   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "strtou16",298,"_strtou16"
;  299	
;  300	uint8_t strtou8(const char *str) {
_strtou8:
.DEFINE "_strtou8"

.VALUE _strtou8

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "strtou8",300,"_strtou8"

.LINE 300

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "result"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "digit"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;  301	    uint8_t result = 0;
.LINE 301

	LD	(IX+%FFFFFFFF),%0
;  302	    const uint8_t maxDiv10 = 255 / 10;
;  303	    const uint8_t maxMod10 = 255 % 10;
;  304	
;  305	    while (*str == ' ' || *str == '\t' || *str == '\n') {
.LINE 305

	JR	L_103
L_104:
;  306	        str++;
.LINE 306

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  307	    }
L_103:
.LINE 307

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_104
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	Z,L_104
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	JR	Z,L_104
;  308	
;  309	    while (*str >= '0' && *str <= '9') {
.LINE 309

	JR	L_111
L_112:
;  310	        uint8_t digit = *str - '0';
.LINE 310

	LD	HL,(IX+%6)
	LD	A,(HL)
	SUB	A,%30
	LD	(IX+%FFFFFFFE),A
;  311	        if (result > maxDiv10 || (result == maxDiv10 && digit > maxMod10)) {
.LINE 311

	LD	A,%19
	CP	A,(IX+%FFFFFFFF)
	JR	C,L_108
	LD	A,(IX+%FFFFFFFF)
	CP	A,%19
	JR	NZ,L_109
	LD	A,%5
	CP	A,(IX+%FFFFFFFE)
	JR	NC,L_109
L_108:
;  312	            return 255;
.LINE 312

	LD	A,%FF
	JR	L_115
;  313	        }
L_109:
.LINE 313

;  314	        result = result * 10 + digit;
.LINE 314

	LD	B,%A
	LD	C,(IX+%FFFFFFFF)
	MLT	BC
	LD	A,C
	ADD	A,(IX+%FFFFFFFE)
	LD	(IX+%FFFFFFFF),A
;  315	        str++;
.LINE 315

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  316	    }
L_111:
.LINE 316

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L__79
	JP	PE,L_114
	JR	L__80
L__79:
	JP	PO,L_114
L__80:
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L__81
	JP	PE,L_112
	JR	L__82
L__81:
	JP	PO,L_112
L__82:
L_114:
;  317	
;  318	    return result;
.LINE 318

	LD	A,(IX+%FFFFFFFF)
;  319	}
L_115:
.LINE 319

	LD	SP,IX
	POP	IX
	RET	


;**************************** _strtou8 ***************************
;Name                         Addr/Register   Size   Type
;digit                                 IX-2      1   variable
;result                                IX-1      1   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "strtou8",319,"_strtou8"
;  320	
;  321	uint24_t strtou24(const char *str) {
_strtou24:
.DEFINE "_strtou24"

.VALUE _strtou24

.CLASS 2

.TYPE 78

.ENDEF

.BEGFUNC "strtou24",321,"_strtou24"

.LINE 321

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "result"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

.DEFINE "digit"

.CLASS 65

.VALUE -8

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
	DEC	SP
;  322	    uint32_t result = 0;
.LINE 322

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
;  323	    const uint32_t maxDiv10 = 1677721;
;  324	    const uint32_t maxMod10 = 5;
;  325	
;  326	    while (*str == ' ' || *str == '\t' || *str == '\n') {
.LINE 326

	JR	L_119
L_120:
;  327	        str++;
.LINE 327

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  328	    }
L_119:
.LINE 328

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_120
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	Z,L_120
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	JR	Z,L_120
;  329		
;  330	    while (*str >= '0' && *str <= '9') {
.LINE 330

	JR	L_127
L_128:
;  331	        uint32_t digit = *str - '0';
.LINE 331

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	E,H
	LD	BC,48
	XOR	A,A
	CALL	__lsub
	LD	(IX+%FFFFFFF8),HL
	LD	(IX+%FFFFFFFB),E
;  332	        if (result > maxDiv10 || (result == maxDiv10 && digit > maxMod10)) {
.LINE 332

	LD	HL,1677721
	LD	E,%0
	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	C,L_124
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,1677721
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_125
	LD	HL,5
	LD	E,%0
	LD	BC,(IX+%FFFFFFF8)
	LD	A,(IX+%FFFFFFFB)
	CALL	__lcmpu
	JR	NC,L_125
L_124:
;  333	            return 16777215;
.LINE 333

	LD	HL,16777215
	JR	L_131
;  334	        }
L_125:
.LINE 334

;  335	        result = result * 10 + digit;
.LINE 335

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,10
	XOR	A,A
	CALL	__lmulu
	LD	BC,(IX+%FFFFFFF8)
	LD	A,(IX+%FFFFFFFB)
	CALL	__ladd
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;  336	        str++;
.LINE 336

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  337	    }
L_127:
.LINE 337

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L__92
	JP	PE,L_130
	JR	L__93
L__92:
	JP	PO,L_130
L__93:
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L__94
	JP	PE,L_128
	JR	L__95
L__94:
	JP	PO,L_128
L__95:
L_130:
;  338	
;  339	    return result;
.LINE 339

	LD	HL,(IX+%FFFFFFFC)
;  340	}
L_131:
.LINE 340

	LD	SP,IX
	POP	IX
	RET	


;**************************** _strtou24 ***************************
;Name                         Addr/Register   Size   Type
;digit                                 IX-8      4   variable
;result                                IX-4      4   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 17 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "strtou24",340,"_strtou24"
;  341	
;  342	int main(int argc, char * argv[]) {
_main:
.DEFINE "_main"

.VALUE _main

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "main",342,"_main"

.LINE 342

.DEFINE "argc"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "argv"

.CLASS 65

.VALUE 9

.TYPE 290

.ENDEF

.DEFINE "bitmap_slot"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -7

.TYPE 14

.ENDEF

.DEFINE "bmp"

.CLASS 65

.VALUE -12

.TAG "NONAME6"

.TYPE 8

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -18

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFDE
	LD	SP,HL
;  343	
;  344	    uint24_t x, y;
;  345		uint8_t bitmap_slot = 0;
.LINE 345

	LD	(IX+%FFFFFFFF),%0
;  346		bmp_info bmp;
;  347		
;  348		//Args = 0:binary name, 1:filname, 2:slot, 3:topleft, 3:topright
;  349		
;  350		if ((argc < 2) || (argc == 4) || (argc > 5)) {
.LINE 350

	LD	BC,2
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JP	M,L__110
	JP	PE,L_134
	JR	L__111
L__110:
	JP	PO,L_134
L__111:
	LD	BC,4
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_134
	LD	BC,(IX+%6)
	LD	HL,5
	OR	A,A
	SBC	HL,BC
	JP	P,L__112
	JP	PE,L_136
	JR	L__113
L__112:
	JP	PO,L_136
L__113:
L_134:
;  351	        printf("Usage is %s <filename> [bitmap slot] [top-left x] [top-left y]\r\n", argv[0]);
.LINE 351

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__100
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	HL,(IX+%9)
	LD	BC,(HL)
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__101
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  352	        return 0;
.LINE 352

	OR	A,A
	SBC	HL,HL
	JR	L_152
;  353	    }
L_136:
.LINE 353

;  354		
;  355		if (argc > 2) bitmap_slot = strtou8(argv[2]);
.LINE 355

	LD	BC,(IX+%6)
	LD	HL,2
	OR	A,A
	SBC	HL,BC
	JP	P,L__114
	JP	PE,L_150
	JR	L__115
L__114:
	JP	PO,L_150
L__115:
	LD	IY,(IX+%9)
	LEA	HL,IY+%6
	LD	BC,(HL)
	PUSH	BC
	CALL	_strtou8
	POP	BC
	LD	(IX+%FFFFFFFF),A
L_150:
;  356		
;  357	    //vdp_mode(8);
;  358		
;  359		if (argc == 2) {
.LINE 359

	LD	BC,2
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_149
;  360	
;  361			bmp = load_bmp_big(argv[1], 0);
.LINE 361

	LD	BC,0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	PEA	IX+%FFFFFFE9
	CALL	_load_bmp_big
	POP	BC
	POP	BC
	POP	BC
	LEA	DE,IX+%FFFFFFF4
	LD	BC,5
	LDIR	
;  362			
;  363		} else if (argc == 3) {
.LINE 363

	JR	L_151
L_149:
	LD	BC,3
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_147
;  364			
;  365			bmp = load_bmp_big(argv[1], bitmap_slot);
.LINE 365

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	PEA	IX+%FFFFFFE4
	CALL	_load_bmp_big
	POP	BC
	POP	BC
	POP	BC
	LEA	DE,IX+%FFFFFFF4
	LD	BC,5
	LDIR	
;  366			
;  367		} else if (argc == 5) {
.LINE 367

	JR	L_151
L_147:
	LD	BC,5
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_151
;  368		
;  369			bmp = load_bmp_big(argv[1], bitmap_slot);
.LINE 369

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	PEA	IX+%FFFFFFDF
	CALL	_load_bmp_big
	POP	BC
	POP	BC
	POP	BC
	LEA	DE,IX+%FFFFFFF4
	LD	BC,5
	LDIR	
;  370			
;  371			if (argv[3][0] == 'C' || argv[3][0] == 'c') x = (getsysvar_scrwidth() - bmp.bmp_width) / 2;
.LINE 371

	LD	IY,(IX+%9)
	LEA	IY,IY+%9
	LD	(IX+%FFFFFFF1),IY
	LD	HL,(IX+%FFFFFFF1)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,67
	OR	A,A
	SBC	HL,BC
	JR	Z,L_138
	LD	HL,(IX+%FFFFFFF1)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,99
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_139
L_138:
	LD	(IX+%FFFFFFDE),A
	CALL	_getsysvar_scrwidth
	LD	A,(IX+%FFFFFFDE)
	LD	BC,HL
	CALL	__stoiu
	LD	DE,HL
	LD	BC,(IX+%FFFFFFF4)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	LD	BC,2
	CALL	__idivs
	LD	(IX+%FFFFFFF9),HL
;  372			else x = strtou16(argv[4]);
.LINE 372

	JR	L_143
L_139:
	LD	IY,(IX+%9)
	LEA	HL,IY+%C
	LD	BC,(HL)
	PUSH	BC
	CALL	_strtou16
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	(IX+%FFFFFFF9),HL
L_143:
;  373			
;  374			if (argv[4][0] == 'C' || argv[4][0] == 'c') y = (getsysvar_scrheight() - bmp.bmp_height) / 2;
.LINE 374

	LD	IY,(IX+%9)
	LEA	IY,IY+%C
	LD	(IX+%FFFFFFFC),IY
	LD	HL,(IX+%FFFFFFFC)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,67
	OR	A,A
	SBC	HL,BC
	JR	Z,L_141
	LD	HL,(IX+%FFFFFFFC)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,99
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_142
L_141:
	LD	(IX+%FFFFFFDE),A
	CALL	_getsysvar_scrheight
	LD	A,(IX+%FFFFFFDE)
	LD	BC,HL
	CALL	__stoiu
	LD	DE,HL
	LD	BC,(IX+%FFFFFFF6)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	LD	BC,2
	CALL	__idivs
	LD	(IX+%FFFFFFEE),HL
;  375			else y = strtou16(argv[4]);
.LINE 375

	JR	L_144
L_142:
	LD	HL,(IX+%FFFFFFFC)
	LD	BC,(HL)
	PUSH	BC
	CALL	_strtou16
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	(IX+%FFFFFFEE),HL
L_144:
;  376			
;  377			vdp_bitmapDraw(bitmap_slot,x,y);
.LINE 377

	LD	BC,(IX+%FFFFFFEE)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_vdp_bitmapDraw
	POP	BC
	POP	BC
	POP	BC
;  378			
;  379		}
L_151:
.LINE 379

;  380	
;  381	    return 0;
.LINE 381

	OR	A,A
	SBC	HL,HL
L_152:
.LINE 382

	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_vdp_bitmapDraw                     IMPORT  -----   function
;_getsysvar_scrheight                IMPORT  -----   function
;_getsysvar_scrwidth                 IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;y                                    IX-18      3   variable
;G_2                                  IX-15      3   variable
;bmp                                  IX-12      5   variable
;x                                     IX-7      3   variable
;G_3                                   IX-4      3   variable
;bitmap_slot                           IX-1      1   variable
;argv                                  IX+9      3   parameter
;argc                                  IX+6      3   parameter


; Stack Frame Size: 46 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "main",382,"_main"
	SEGMENT STRSECT
L__100:
	DB	"Usage is "
	DB	0
L__101:
	DB	" <filename> [bitmap slot] [top-left x] [top-left y]"
	DB	13,10,0
	XREF _write16bit:ROM
	XREF _vdp_bitmapDraw:ROM
	XREF _vdp_bitmapSelect:ROM
	XREF _mos_getfil:ROM
	XREF _mos_flseek:ROM
	XREF _mos_fread:ROM
	XREF _mos_fgetc:ROM
	XREF _mos_fclose:ROM
	XREF _mos_fopen:ROM
	XREF _getsysvar_scrheight:ROM
	XREF _getsysvar_scrwidth:ROM
	XREF _mos_puts:ROM
	XREF _waitvblank:ROM
	XREF _putch:ROM
	XREF _memcpy:ROM
	XREF _malloc:ROM
	XREF _free:ROM
	XREF ___print_sendstring:ROM
	XREF ___print_xputch:ROM
	XREF ___print_uputch:ROM
	XREF __lcmps:ROM
	XREF __lcmpu:ROM
	XREF __ladd:ROM
	XREF __lsub:ROM
	XREF __idivs:ROM
	XREF __ldivs:ROM
	XREF __imuls:ROM
	XREF __lmuls:ROM
	XREF __lmulu:ROM
	XREF __smulu:ROM
	XREF __irems:ROM
	XREF __lrems:ROM
	XREF __stoiu:ROM
	XREF __itol:ROM
	XREF __ildix:ROM
	XREF __istix:ROM
	XREF __ladd_b:ROM
	XDEF _main
	XDEF _strtou24
	XDEF _strtou8
	XDEF _strtou16
	XDEF _load_bmp_big
	XDEF _reorder_and_insert
	XDEF _reorder
	XDEF _twiddle_buffer
	XDEF _flip
	XDEF _max
	XDEF _min
	XDEF _delay_secs
	END
