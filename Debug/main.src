; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optspeed -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\main.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME0",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME1"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME2"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME2",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",8
.DEFINE "baudRate"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "dataBits"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stopBits"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "parity"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flowcontrol"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "eir"
.VALUE 7
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",15
.DEFINE "fs"
.VALUE 0
.CLASS 8
.TYPE 46
.ENDEF
.DEFINE "id"
.VALUE 3
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "attr"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "stat"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "sclust"
.VALUE 7
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "objsize"
.VALUE 11
.CLASS 8
.TYPE 15
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",36
.DEFINE "obj"
.VALUE 0
.CLASS 8
.TAG "NONAME4"
.TYPE 8
.ENDEF
.DEFINE "flag"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "err"
.VALUE 16
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "fptr"
.VALUE 17
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "clust"
.VALUE 21
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "sect"
.VALUE 25
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_sect"
.VALUE 29
.CLASS 8
.TYPE 15
.ENDEF
.DEFINE "dir_ptr"
.VALUE 33
.CLASS 8
.TYPE 46
.ENDEF
.ENDREC "NONAME5"
;    1	//Copyright HeathenUK 2023, others' copyrights (Envenomator, Dean Belfield, etc.) unaffected.
;    2	
;    3	#include <stdio.h>
;    4	#include <stdlib.h>
;    5	#include <ctype.h>
;    6	#include <stdint.h>
;    7	#include <string.h>
;    8	#include <eZ80.h>
;    9	#include <defines.h>
;   10	#include "mos-interface.h"
;   11	#include "vdp.h"
;   12	
;   13	typedef struct {
;   14		
;   15		uint16_t bmp_width;
;   16		uint16_t bmp_height;
;   17		uint8_t  bmp_bitdepth;
;   18		
;   19	} bmp_info;
.BEGREC "NONAME6",5
.DEFINE "bmp_width"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "bmp_height"
.VALUE 2
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "bmp_bitdepth"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME6"
;   20	
;   21	extern void write16bit(uint16_t w);
;   22	extern void write24bit(uint24_t w);
;   23	extern void write32bit(uint32_t w);
;   24	
;   25	void delay_secs(UINT16 ticks_end) { //1 sec ticks
_delay_secs:
.DEFINE "_delay_secs"

.VALUE _delay_secs

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "delay_secs",25,"_delay_secs"

.LINE 25

.DEFINE "ticks_end"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

.DEFINE "ticks"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;   26		
;   27		UINT32 ticks = 0;
.LINE 27

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
;   28		ticks_end *= 60;
.LINE 28

	LD.LIS	HL,60
	LD	BC,(IX+%6)
	CALL	__smulu
	LD	(IX+%6),L
	LD	(IX+%7),H
;   29		while(true) {
L_3:
.LINE 29

;   30			
;   31			waitvblank();
.LINE 31

	CALL	_waitvblank
;   32			ticks++;
.LINE 32

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;   33			if(ticks >= ticks_end) break;
.LINE 33

	LD	BC,(IX+%6)
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	C,L_3
;   34			
;   35		}
;   36		
;   37	}
.LINE 37

	LD	SP,IX
	POP	IX
	RET	


;**************************** _delay_secs ***************************
;Name                         Addr/Register   Size   Type
;_waitvblank                         IMPORT  -----   function
;ticks                                 IX-4      4   variable
;ticks_end                             IX+6      2   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "delay_secs",37,"_delay_secs"
;   38	
;   39	int min(int a, int b) {
_min:
.DEFINE "_min"

.VALUE _min

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "min",39,"_min"

.LINE 39

.DEFINE "a"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   40	    if (a > b)
.LINE 40

	LD	BC,(IX+%6)
	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JP	P,L__3
	JP	PE,L_6
	JR	L__4
L__3:
	JP	PO,L_6
L__4:
;   41	        return b;
.LINE 41

	LD	HL,(IX+%9)
	JR	L_7
L_6:
;   42	    return a;
.LINE 42

	LD	HL,(IX+%6)
;   43	}
L_7:
.LINE 43

	LD	SP,IX
	POP	IX
	RET	


;**************************** _min ***************************
;Name                         Addr/Register   Size   Type
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "min",43,"_min"
;   44	
;   45	int max(int a, int b) {
_max:
.DEFINE "_max"

.VALUE _max

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "max",45,"_max"

.LINE 45

.DEFINE "a"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   46	    if (a > b)
.LINE 46

	LD	BC,(IX+%6)
	LD	HL,(IX+%9)
	OR	A,A
	SBC	HL,BC
	JP	P,L__7
	JP	PE,L_9
	JR	L__8
L__7:
	JP	PO,L_9
L__8:
;   47	        return a;
.LINE 47

	LD	HL,(IX+%6)
	JR	L_10
L_9:
;   48	    return b;
.LINE 48

	LD	HL,(IX+%9)
;   49	}
L_10:
.LINE 49

	LD	SP,IX
	POP	IX
	RET	


;**************************** _max ***************************
;Name                         Addr/Register   Size   Type
;b                                     IX+9      3   parameter
;a                                     IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "max",49,"_max"
;   50	
;   51	void flip(uint32_t * framebuffer, int width, int height) {
_flip:
.DEFINE "_flip"

.VALUE _flip

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "flip",51,"_flip"

.LINE 51

.DEFINE "framebuffer"

.CLASS 65

.VALUE 6

.TYPE 47

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE 12

.TYPE 4

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "row_buffer"

.CLASS 65

.VALUE -5

.TYPE 47

.ENDEF

.DEFINE "row_size"

.CLASS 65

.VALUE -8

.TYPE 4

.ENDEF

.DEFINE "top_row"

.CLASS 65

.VALUE -11

.TYPE 47

.ENDEF

.DEFINE "bottom_row"

.CLASS 65

.VALUE -14

.TYPE 47

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF1
	LD	SP,HL
;   52	    uint16_t y;
;   53	    uint32_t * row_buffer = (uint32_t * ) malloc(sizeof(uint32_t) * width);
.LINE 53

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	(IX+%FFFFFFF1),A
	CALL	_malloc
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	LD	(IX+%FFFFFFFB),HL
;   54	    int row_size = width * sizeof(uint32_t);
.LINE 54

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	LD	(IX+%FFFFFFF8),HL
;   55	
;   56	    for (y = 0; y < height / 2; y++) {
.LINE 56

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_14
L_12:
;   57	        uint32_t * top_row = framebuffer + y * width;
.LINE 57

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF5),HL
;   58	        uint32_t * bottom_row = framebuffer + (height - y - 1) * width;
.LINE 58

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	DEC	HL
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF2),HL
;   59	
;   60	        memcpy(row_buffer, top_row, row_size);
.LINE 60

	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	LD	(IX+%FFFFFFF1),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	POP	BC
	POP	BC
;   61	        memcpy(top_row, bottom_row, row_size);
.LINE 61

	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF2)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	(IX+%FFFFFFF1),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	POP	BC
	POP	BC
;   62	        memcpy(bottom_row, row_buffer, row_size);
.LINE 62

	LD	BC,(IX+%FFFFFFF8)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF2)
	PUSH	BC
	LD	(IX+%FFFFFFF1),A
	CALL	_memcpy
	LD	A,(IX+%FFFFFFF1)
	POP	BC
	POP	BC
	POP	BC
	LD	HL,(IX+%FFFFFFFE)
	INC	HL
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;   63	    }
L_14:
.LINE 63

	LD	BC,2
	LD	HL,(IX+%C)
	CALL	__idivs
	LD	DE,HL
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	OR	A,A
	SBC	HL,DE
	JP	M,L__11
	JP	PE,L_12
	JR	L__12
L__11:
	JP	PO,L_12
L__12:
;   64	
;   65	    free(row_buffer);
.LINE 65

	LD	BC,(IX+%FFFFFFFB)
	PUSH	BC
	CALL	_free
	POP	BC
;   66	}
.LINE 66

	LD	SP,IX
	POP	IX
	RET	


;**************************** _flip ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_memcpy                             IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;bottom_row                           IX-14      3   variable
;top_row                              IX-11      3   variable
;row_size                              IX-8      3   variable
;row_buffer                            IX-5      3   variable
;y                                     IX-2      2   variable
;height                               IX+12      3   parameter
;width                                 IX+9      3   parameter
;framebuffer                           IX+6      3   parameter


; Stack Frame Size: 30 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "flip",66,"_flip"
;   67	
;   68	void twiddle_buffer(char* buffer, int width, int height) {
_twiddle_buffer:
.DEFINE "_twiddle_buffer"

.VALUE _twiddle_buffer

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "twiddle_buffer",68,"_twiddle_buffer"

.LINE 68

.DEFINE "buffer"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE 12

.TYPE 4

.ENDEF

.DEFINE "col"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "tempRow"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "oppositeRowPtr"

.CLASS 65

.VALUE -9

.TYPE 34

.ENDEF

.DEFINE "rowPtr"

.CLASS 65

.VALUE -12

.TYPE 34

.ENDEF

.DEFINE "row"

.CLASS 65

.VALUE -15

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFE4
	LD	SP,HL
;   69	    int row, col;
;   70	    char* rowPtr;
;   71		char* oppositeRowPtr;
;   72		char* tempRow = (char*)malloc(width * 4);
.LINE 72

	LD	HL,(IX+%9)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	(IX+%FFFFFFE4),A
	CALL	_malloc
	LD	A,(IX+%FFFFFFE4)
	POP	BC
	LD	(IX+%FFFFFFFA),HL
;   73	
;   74	    //Iterate over each row
;   75	    for (row = 0; row < height / 2; row++) {
.LINE 75

	LD	BC,0
	LD	(IX+%FFFFFFF1),BC
	JR	L_24
L_22:
;   76	        rowPtr = buffer + row * width * 4;
.LINE 76

	LD	HL,(IX+%FFFFFFF1)
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF4),HL
;   77	        oppositeRowPtr = buffer + (height - row - 1) * width * 4;
.LINE 77

	LD	BC,(IX+%FFFFFFF1)
	LD	HL,(IX+%C)
	OR	A,A
	SBC	HL,BC
	DEC	HL
	LD	BC,(IX+%9)
	CALL	__imuls
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFF7),HL
;   78	
;   79	        //Swap bytes within each row (BGRA to RGBA)
;   80	        for (col = 0; col < width; col++) {
.LINE 80

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_21
L_19:
;   81	            tempRow[col * 4] = oppositeRowPtr[col * 4 + 2]; // R
.LINE 81

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,(IX+%FFFFFFF7)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	LD	A,(IY+%2)
	LD	(HL),A
;   82	            tempRow[col * 4 + 1] = oppositeRowPtr[col * 4 + 1]; // G
.LINE 82

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,DE
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	INC	HL
	LD	A,(IY+%1)
	LD	(HL),A
;   83	            tempRow[col * 4 + 2] = oppositeRowPtr[col * 4]; // B
.LINE 83

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	INC	HL
	INC	HL
	LD	A,(IY)
	LD	(HL),A
;   84	            tempRow[col * 4 + 3] = oppositeRowPtr[col * 4 + 3]; // A
.LINE 84

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	IY,HL
	LD	(IX+%FFFFFFEE),HL	; spill
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFEB),HL	; spill
	LD	BC,DE
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFEB)	; unspill
	LD	A,(HL)
	LD	(IY+%3),A
;   85	
;   86	            oppositeRowPtr[col * 4] = rowPtr[col * 4 + 2]; // R
.LINE 86

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,DE
	LD	A,(IY+%2)
	LD	(HL),A
;   87	            oppositeRowPtr[col * 4 + 1] = rowPtr[col * 4 + 1]; // G
.LINE 87

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,DE
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	INC	HL
	LD	A,(IY+%1)
	LD	(HL),A
;   88	            oppositeRowPtr[col * 4 + 2] = rowPtr[col * 4]; // B
.LINE 88

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,DE
	INC	HL
	INC	HL
	LD	A,(IY)
	LD	(HL),A
;   89	            oppositeRowPtr[col * 4 + 3] = rowPtr[col * 4 + 3]; // A
.LINE 89

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	IY,HL
	LD	(IX+%FFFFFFEE),HL	; spill
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFE8),HL	; spill
	LD	BC,DE
	LD	HL,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFE8)	; unspill
	LD	A,(HL)
	LD	(IY+%3),A
;   90	
;   91	            rowPtr[col * 4] = tempRow[col * 4]; // R
.LINE 91

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	LD	A,(IY)
	LD	(HL),A
;   92	            rowPtr[col * 4 + 1] = tempRow[col * 4 + 1]; // G
.LINE 92

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	IY,HL
	LD	BC,DE
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	INC	HL
	LD	A,(IY+%1)
	LD	(HL),A
;   93	            rowPtr[col * 4 + 2] = tempRow[col * 4 + 2]; // B
.LINE 93

	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,DE
	LD	IY,HL
	LD	DE,BC
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,DE
	INC	HL
	INC	HL
	LD	A,(IY+%2)
	LD	(HL),A
;   94	            rowPtr[col * 4 + 3] = tempRow[col * 4 + 3]; // A
.LINE 94

	LD	HL,(IX+%FFFFFFFA)
	ADD	HL,BC
	LD	IY,HL
	LD	(IX+%FFFFFFEE),HL	; spill
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFE5),HL	; spill
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%FFFFFFE5)	; unspill
	LD	A,(HL)
	LD	(IY+%3),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;   95	        }
L_21:
.LINE 95

	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	JP	M,L__16
	JP	PE,L_19
	JR	L__17
L__16:
	JP	PO,L_19
L__17:
	LD	BC,(IX+%FFFFFFF1)
	INC	BC
	LD	(IX+%FFFFFFF1),BC
;   96	    }
L_24:
.LINE 96

	LD	BC,2
	LD	HL,(IX+%C)
	CALL	__idivs
	LD	BC,HL
	LD	HL,(IX+%FFFFFFF1)
	OR	A,A
	SBC	HL,BC
	JP	M,L__18
	JP	PE,L_22
	JR	L__19
L__18:
	JP	PO,L_22
L__19:
;   97		free(tempRow);
.LINE 97

	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_free
	POP	BC
;   98	}
.LINE 98

	LD	SP,IX
	POP	IX
	RET	


;**************************** _twiddle_buffer ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;row                                  IX-15      3   variable
;rowPtr                               IX-12      3   variable
;oppositeRowPtr                        IX-9      3   variable
;tempRow                               IX-6      3   variable
;col                                   IX-3      3   variable
;height                               IX+12      3   parameter
;width                                 IX+9      3   parameter
;buffer                                IX+6      3   parameter


; Stack Frame Size: 43 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "twiddle_buffer",98,"_twiddle_buffer"
;   99	
;  100	void reorder(char *arr, uint16_t length) {
_reorder:
.DEFINE "_reorder"

.VALUE _reorder

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "reorder",100,"_reorder"

.LINE 100

.DEFINE "arr"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "length"

.CLASS 65

.VALUE 9

.TYPE 13

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "temp"

.CLASS 65

.VALUE -3

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
;  101	    uint16_t i;
;  102		for (i = 0; i < length; i += 4) {
.LINE 102

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_30
L_28:
;  103	        if (i + 2 < length) {
.LINE 103

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	DE,HL
	INC	DE
	INC	DE
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JP	P,L__23
	JP	PE,L_29
	JR	L__24
L__23:
	JP	PO,L_29
L__24:
;  104	            uint8_t temp = arr[i];
.LINE 104

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	(IX+%FFFFFFFA),HL
	LD	A,(HL)
	LD	(IX+%FFFFFFFD),A
;  105	            arr[i] = arr[i + 2];
.LINE 105

	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	A,(IY+%2)
	LD	(HL),A
;  106	            arr[i + 2] = temp;
.LINE 106

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	INC	HL
	INC	HL
	LD	A,(IX+%FFFFFFFD)
	LD	(HL),A
;  107	        }
;  108	    }
L_29:
.LINE 108

	LD	IY,(IX+%FFFFFFFE)
	LEA	HL,IY+%4
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
L_30:
	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_28
;  109	}
.LINE 109

	LD	SP,IX
	POP	IX
	RET	


;**************************** _reorder ***************************
;Name                         Addr/Register   Size   Type
;temp                                  IX-3      1   variable
;i                                     IX-2      2   variable
;length                                IX+9      2   parameter
;arr                                   IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "reorder",109,"_reorder"
;  110	
;  111	void reorder_and_insert(char *arr, uint16_t length, char **new_arr, uint16_t *new_length, char insert_value) {
_reorder_and_insert:
.DEFINE "_reorder_and_insert"

.VALUE _reorder_and_insert

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "reorder_and_insert",111,"_reorder_and_insert"

.LINE 111

.DEFINE "arr"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "length"

.CLASS 65

.VALUE 9

.TYPE 13

.ENDEF

.DEFINE "new_arr"

.CLASS 65

.VALUE 12

.TYPE 290

.ENDEF

.DEFINE "new_length"

.CLASS 65

.VALUE 15

.TYPE 45

.ENDEF

.DEFINE "insert_value"

.CLASS 65

.VALUE 18

.TYPE 2

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "j"

.CLASS 65

.VALUE -4

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFED
	LD	SP,HL
;  112	
;  113		uint16_t i, j = 0;
.LINE 113

	LD	(IX+%FFFFFFFC),%0
	LD	(IX+%FFFFFFFD),%0
;  114	    *new_length = (length / 3) * 4 + (length % 3);
.LINE 114

	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,3
	CALL	__idivs
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,3
	CALL	__irems
	ADD	HL,DE
	LD	BC,HL
	LD	HL,(IX+%F)
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  115	    *new_arr = (char *) malloc(*new_length * sizeof(char));
.LINE 115

	LD	HL,(IX+%F)
	LD	BC,(HL)
	CALL	__stoiu
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	IY,(IX+%C)
	LD	(IY),HL
;  116	
;  117	    for (i = 0; i < length; i += 3) {
.LINE 117

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
	JR	L_42
L_40:
;  118	        
;  119	        (*new_arr)[j] = (i + 2 < length) ? arr[i + 2] : 0;
.LINE 119

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	DE,HL
	INC	DE
	INC	DE
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JP	P,L__29
	JP	PE,L_34
	JR	L__30
L__29:
	JP	PO,L_34
L__30:
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	(IX+%FFFFFFF9),HL
	JR	L_35
L_34:
	LD	BC,0
	LD	(IX+%FFFFFFF9),BC
L_35:
	LD	IY,(IX+%C)
	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	BC,(IY)
	ADD	HL,BC
	LD	(IX+%FFFFFFF3),HL
	LD	A,(IX+%FFFFFFF9)
	LD	HL,(IX+%FFFFFFF3)
	LD	(HL),A
;  120	        (*new_arr)[j + 1] = (i + 1 < length) ? arr[i + 1] : 0;
.LINE 120

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	DE,HL
	INC	DE
	LD	BC,(IX+%9)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	JP	P,L__31
	JP	PE,L_38
	JR	L__32
L__31:
	JP	PO,L_38
L__32:
	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	INC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	(IX+%FFFFFFF6),HL
	JR	L_39
L_38:
	LD	BC,0
	LD	(IX+%FFFFFFF6),BC
L_39:
	LD	A,(IX+%FFFFFFF6)
	LD	HL,(IX+%FFFFFFF3)
	INC	HL
	LD	(HL),A
;  121	        (*new_arr)[j + 2] = arr[i];
.LINE 121

	LD	BC,(IX+%FFFFFFFE)
	CALL	__stoiu
	LD	BC,(IX+%6)
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+%C)
	LD	(IX+%FFFFFFED),HL	; spill
	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	(IX+%FFFFFFF0),HL	; spill
	LD	HL,(IX+%FFFFFFED)	; unspill
	LD	BC,(HL)
	LD	HL,(IX+%FFFFFFF0)	; unspill
	ADD	HL,BC
	INC	HL
	INC	HL
	LD	A,(IY)
	LD	(HL),A
;  122	        
;  123	        (*new_arr)[j + 3] = 0xFF;
.LINE 123

	LD	IY,(IX+%C)
	LD	BC,(IX+%FFFFFFFC)
	CALL	__stoiu
	LD	BC,(IY)
	ADD	HL,BC
	LD	IY,HL
	LEA	HL,IY+%3
	LD	(HL),%FF
;  124	
;  125	        j += 4;
.LINE 125

	LD	IY,(IX+%FFFFFFFC)
	LEA	HL,IY+%4
	LD	(IX+%FFFFFFFC),L
	LD	(IX+%FFFFFFFD),H
	LD	IY,(IX+%FFFFFFFE)
	LEA	HL,IY+%3
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  126	    }
L_42:
.LINE 126

	LD	BC,(IX+%9)
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_40
;  127		free(new_arr);
.LINE 127

	LD	BC,(IX+%C)
	PUSH	BC
	CALL	_free
	POP	BC
;  128	}
.LINE 128

	LD	SP,IX
	POP	IX
	RET	


;**************************** _reorder_and_insert ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;G_0                                  IX-13      3   variable
;temp36                               IX-10      3   variable
;temp32                                IX-7      3   variable
;j                                     IX-4      2   variable
;i                                     IX-2      2   variable
;insert_value                         IX+18      1   parameter
;new_length                           IX+15      3   parameter
;new_arr                              IX+12      3   parameter
;length                                IX+9      2   parameter
;arr                                   IX+6      3   parameter


; Stack Frame Size: 40 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "reorder_and_insert",128,"_reorder_and_insert"
;  129	
;  130	bmp_info load_bmp_big(const char * filename, UINT8 slot) { //Uses 64x64x4 chunks
_load_bmp_big:
.DEFINE "_load_bmp_big"

.VALUE _load_bmp_big

.CLASS 2

.TAG "NONAME6"

.TYPE 72

.ENDEF

.BEGFUNC "load_bmp_big",130,"_load_bmp_big"

.LINE 130

.DEFINE "filename"

.CLASS 65

.VALUE 9

.TYPE 194

.ENDEF

.DEFINE "slot"

.CLASS 65

.VALUE 12

.TYPE 12

.ENDEF

.DEFINE "file"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -5

.TYPE 5

.ENDEF

.DEFINE "bit_depth"

.CLASS 65

.VALUE -9

.TYPE 5

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -13

.TYPE 5

.ENDEF

.DEFINE "src"

.CLASS 65

.VALUE -16

.TYPE 34

.ENDEF

.DEFINE "height"

.CLASS 65

.VALUE -20

.TYPE 5

.ENDEF

.DEFINE "return_info"

.CLASS 65

.VALUE -25

.TAG "NONAME6"

.TYPE 8

.ENDEF

.DEFINE "width"

.CLASS 65

.VALUE -29

.TYPE 5

.ENDEF

.DEFINE "row_padding"

.CLASS 65

.VALUE -37

.TYPE 5

.ENDEF

.DEFINE "index"

.CLASS 65

.VALUE -42

.TYPE 12

.ENDEF

.DEFINE "color_table_size"

.CLASS 65

.VALUE -46

.TYPE 15

.ENDEF

.DEFINE "biSize"

.CLASS 65

.VALUE -50

.TYPE 15

.ENDEF

.DEFINE "fo"

.CLASS 65

.VALUE -53

.TAG "NONAME5"

.TYPE 40

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -57

.TYPE 5

.ENDEF

.DEFINE "r"

.CLASS 65

.VALUE -58

.TYPE 12

.ENDEF

.DEFINE "g"

.CLASS 65

.VALUE -59

.TYPE 12

.ENDEF

.DEFINE "b"

.CLASS 65

.VALUE -60

.TYPE 12

.ENDEF

.DEFINE "non_pad_row"

.CLASS 65

.VALUE -63

.TYPE 4

.ENDEF

.DEFINE "new_row_size"

.CLASS 65

.VALUE -65

.TYPE 13

.ENDEF

.DEFINE "row_24bpp"

.CLASS 65

.VALUE -68

.TYPE 34

.ENDEF

.DEFINE "image_start"

.CLASS 65

.VALUE -72

.TYPE 5

.ENDEF

.DEFINE "image_buffer"

.CLASS 65

.VALUE -75

.TYPE 34

.ENDEF

.DEFINE "greenMask"

.CLASS 65

.VALUE -79

.DIM 4

.TYPE 98

.ENDEF

.DEFINE "non_pad_row"

.CLASS 65

.VALUE -82

.TYPE 4

.ENDEF

.DEFINE "blueMask"

.CLASS 65

.VALUE -86

.DIM 4

.TYPE 98

.ENDEF

.DEFINE "alphaMask"

.CLASS 65

.VALUE -90

.DIM 4

.TYPE 98

.ENDEF

.DEFINE "redMask"

.CLASS 65

.VALUE -94

.DIM 4

.TYPE 98

.ENDEF

.DEFINE "non_pad_row"

.CLASS 65

.VALUE -97

.TYPE 4

.ENDEF

.DEFINE "header"

.CLASS 65

.VALUE -151

.DIM 54

.TYPE 98

.ENDEF

.DEFINE "color_table"

.CLASS 65

.VALUE -1175

.DIM 1024

.TYPE 98

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-1194
	ADD	HL,SP
	LD	SP,HL
;  131	
;  132	    int32_t image_start, width, height, bit_depth, row_padding = 0, y, x, i;
;  133		char* row_24bpp;
;  134	    uint8_t pixel[4], file, r, g, b, index;
;  135	    char header[54], color_table[1024];
;  136	    uint32_t pixel_value, color_table_size, bytes_per_row;
;  137	    uint32_t biSize;
;  138	    FIL * fo;
;  139		bmp_info return_info;
;  140	
;  141	    char * src;
;  142	    char * image_buffer;
;  143		
;  144		//if (game.vgm_file != NULL) parse_vgm_file(game.vgm_file);
;  145		
;  146		return_info.bmp_width = 0;
.LINE 146

	LD	(IX+%FFFFFFE7),%0
	LD	(IX+%FFFFFFE8),%0
;  147		return_info.bmp_height = 0;
.LINE 147

	LD	(IX+%FFFFFFE9),%0
	LD	(IX+%FFFFFFEA),%0
;  148		return_info.bmp_bitdepth = 0;	
.LINE 148

	LD	(IX+%FFFFFFEB),%0
;  149	
;  150	    file = mos_fopen(filename, fa_read);
.LINE 150

	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  151	    if (!file) {
.LINE 151

	OR	A,A
	JR	NZ,L_46
;  152	        printf("Error: could not open %s.\r\n", filename);
.LINE 152

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__35
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%9)
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__36
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  153	        return return_info;
.LINE 153

	LEA	HL,IX+%6
	LD	DE,(HL)
	LEA	HL,IX+%FFFFFFE7
	LD	BC,5
	LDIR	
	LD	HL,(IX+%6)
	JR	L_96
;  154	    }
L_46:
.LINE 154

;  155	    fo = (FIL * ) mos_getfil(file);
.LINE 155

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_getfil
	POP	BC
	LD	(IX+%FFFFFFCB),HL
;  156	
;  157	    mos_fread(file, header, 54);
.LINE 157

	LD	BC,54
	PUSH	BC
	LD	HL,IX
	LD	BC,-151
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  158	
;  159		image_start = * (uint32_t * ) & header[10];
.LINE 159

	LD	IY,IX
	LD	BC,-151
	ADD	IY,BC
	LEA	HL,IY+%A
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFB8),BC
	LD	(IX+%FFFFFFBB),A
;  160	    biSize = * (uint32_t * ) & header[14];
.LINE 160

	LD	IY,IX
	LD	BC,-151
	ADD	IY,BC
	LEA	HL,IY+%E
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFCE),BC
	LD	(IX+%FFFFFFD1),A
;  161	    width = * (INT32 * ) & header[18];
.LINE 161

	LD	IY,IX
	LD	BC,-151
	ADD	IY,BC
	LEA	HL,IY+%12
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFE3),BC
	LD	(IX+%FFFFFFE6),A
;  162	    height = * (INT32 * ) & header[22];
.LINE 162

	LD	IY,IX
	LD	BC,-151
	ADD	IY,BC
	LEA	HL,IY+%16
	LD	BC,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFEC),BC
	LD	(IX+%FFFFFFEF),A
;  163	    bit_depth = * (uint16_t * ) & header[28];
.LINE 163

	LEA	HL,IX+%FFFFFF85
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	XOR	A,A
	LD	(IX+%FFFFFFF7),BC
	LD	(IX+%FFFFFFFA),A
;  164	    color_table_size = * (uint32_t * ) & header[46];
.LINE 164

	LEA	HL,IX+%FFFFFF97
	LD	DE,(HL)
	INC	HL
	INC	HL
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFD2),DE
	LD	(IX+%FFFFFFD5),A
;  165		
;  166		
;  167	    image_buffer = (char * ) malloc(width * bit_depth / 8);
.LINE 167

	LD	HL,(IX+%FFFFFFE3)
	LD	E,(IX+%FFFFFFE6)
	LD	A,(IX+%FFFFFFFA)
	CALL	__lmuls
	LD	BC,8
	XOR	A,A
	CALL	__ldivs
	PUSH	HL
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFB5),HL
;  168	
;  169	    if (color_table_size == 0 && bit_depth == 8) {
.LINE 169

	LD	HL,(IX+%FFFFFFD2)
	LD	E,(IX+%FFFFFFD5)
	LD	BC,0
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_50
	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,8
	XOR	A,A
	CALL	__lcmps
	JR	NZ,L_50
;  170	        color_table_size = 256;
.LINE 170

	LD	BC,256
	XOR	A,A
	LD	(IX+%FFFFFFD2),BC
	LD	(IX+%FFFFFFD5),A
;  171	    }
L_50:
.LINE 171

;  172	
;  173	    if (color_table_size > 0) mos_fread(file, color_table, color_table_size * 4);
.LINE 173

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(IX+%FFFFFFD2)
	LD	A,(IX+%FFFFFFD5)
	CALL	__lcmpu
	JR	NC,L_67
	LD	HL,(IX+%FFFFFFD2)
	ADD	HL,HL
	ADD	HL,HL
	PUSH	HL
	LD	HL,IX
	LD	BC,-1175
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
L_67:
;  174	
;  175	    // else if (biSize > 40) { //If for any reason there's yet more data in the header
;  176	
;  177	        // i = biSize - 40;
;  178	        // while (i--> 0) {
;  179	            // mos_fgetc(file);
;  180	        // }
;  181	
;  182	    // }
;  183		
;  184		if (biSize > 40) {
.LINE 184

	LD	HL,40
	LD	E,%0
	LD	BC,(IX+%FFFFFFCE)
	LD	A,(IX+%FFFFFFD1)
	CALL	__lcmpu
	JR	NC,L_71
;  185			// If BITMAPV4HEADER or above, expect color masks
;  186			if (biSize >= 108) {
.LINE 186

	LD	HL,(IX+%FFFFFFCE)
	LD	E,(IX+%FFFFFFD1)
	LD	BC,108
	XOR	A,A
	CALL	__lcmpu
	JR	C,L_65
;  187				char redMask[4], greenMask[4], blueMask[4], alphaMask[4];
;  188				mos_fread(file, redMask, 4);
.LINE 188

	LD	BC,4
	PUSH	BC
	PEA	IX+%FFFFFFA2
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  189				mos_fread(file, greenMask, 4);
.LINE 189

	LD	BC,4
	PUSH	BC
	PEA	IX+%FFFFFFB1
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  190				mos_fread(file, blueMask, 4);
.LINE 190

	LD	BC,4
	PUSH	BC
	PEA	IX+%FFFFFFAA
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  191				mos_fread(file, alphaMask, 4);
.LINE 191

	LD	BC,4
	PUSH	BC
	PEA	IX+%FFFFFFA6
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  192					
;  193				if (!(memcmp(redMask, "\x00\x00\xFF\x00", 4) == 0 &&
.LINE 193

	LD	BC,4
	PUSH	BC
	LD	BC,L__42
	PUSH	BC
	PEA	IX+%FFFFFFA2
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_54
;  194					  memcmp(greenMask, "\x00\xFF\x00\x00", 4) == 0 &&
.LINE 194

	LD	BC,4
	PUSH	BC
	LD	BC,L__44
	PUSH	BC
	PEA	IX+%FFFFFFB1
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_54
;  195					  memcmp(blueMask, "\xFF\x00\x00\x00", 4) == 0 &&
.LINE 195

	LD	BC,4
	PUSH	BC
	LD	BC,L__46
	PUSH	BC
	PEA	IX+%FFFFFFAA
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_54
;  196					  memcmp(alphaMask, "\x00\x00\x00\xFF", 4) == 0)) {
.LINE 196

	LD	BC,4
	PUSH	BC
	LD	BC,L__48
	PUSH	BC
	PEA	IX+%FFFFFFA6
	CALL	_memcmp
	POP	BC
	POP	BC
	POP	BC
	LD	BC,0
	OR	A,A
	SBC	HL,BC
	JR	Z,L_59
L_54:
;  197					printf("Error: Pixel format is NOT standard BGRA. Exiting.\n");
.LINE 197

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__50
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  198					mos_fclose(file);
.LINE 198

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  199					return return_info;
.LINE 199

	LEA	HL,IX+%6
	LD	DE,(HL)
	LEA	HL,IX+%FFFFFFE7
	LD	BC,5
	LDIR	
	LD	HL,(IX+%6)
	JR	L_96
;  200				}
L_59:
.LINE 200

;  201					
;  202					// Skip remaining extra header bytes
;  203					for (i = biSize - 108; i > 0; i--) {
.LINE 203

	LD	HL,(IX+%FFFFFFCE)
	LD	E,(IX+%FFFFFFD1)
	LD	BC,16777108
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFF3),HL
	LD	(IX+%FFFFFFF6),E
	JR	L_58
L_56:
;  204						mos_fgetc(file);
.LINE 204

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fgetc
	POP	BC
	LD	HL,(IX+%FFFFFFF3)
	LD	E,(IX+%FFFFFFF6)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFF3),HL
	LD	(IX+%FFFFFFF6),E
;  205					}
L_58:
.LINE 205

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(IX+%FFFFFFF3)
	LD	A,(IX+%FFFFFFF6)
	CALL	__lcmps
	JP	M,L_56
	JR	L_71
;  206			} else {
L_65:
.LINE 206

;  207				// Skip all extra header bytes
;  208				for (i = biSize - 40; i > 0; i--) {
.LINE 208

	LD	HL,(IX+%FFFFFFCE)
	LD	E,(IX+%FFFFFFD1)
	LD	BC,16777176
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFF3),HL
	LD	(IX+%FFFFFFF6),E
	JR	L_63
L_61:
;  209					mos_fgetc(file);
.LINE 209

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fgetc
	POP	BC
	LD	HL,(IX+%FFFFFFF3)
	LD	E,(IX+%FFFFFFF6)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFF3),HL
	LD	(IX+%FFFFFFF6),E
;  210				}
L_63:
.LINE 210

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(IX+%FFFFFFF3)
	LD	A,(IX+%FFFFFFF6)
	CALL	__lcmps
	JP	M,L__64
	JP	PE,L_61
	JR	L__65
L__64:
	JP	PO,L_61
L__65:
;  211			}
;  212		}	
L_71:
.LINE 212

;  213	
;  214	    if ((bit_depth != 32) && (bit_depth != 24) && (bit_depth != 8)) {
.LINE 214

	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,32
	XOR	A,A
	CALL	__lcmps
	JR	Z,L_72
	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,24
	XOR	A,A
	CALL	__lcmps
	JR	Z,L_72
	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,8
	XOR	A,A
	CALL	__lcmps
	JR	Z,L_72
;  215	        printf("Error: unsupported bit depth (not 8, 24 or 32-bit).\n");
.LINE 215

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__56
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  216	        mos_fclose(file);
.LINE 216

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  217	        return return_info;
.LINE 217

	LEA	HL,IX+%6
	LD	DE,(HL)
	LEA	HL,IX+%FFFFFFE7
	LD	BC,5
	LDIR	
	LD	HL,(IX+%6)
	JR	L_96
;  218	    }
L_72:
.LINE 218

;  219	
;  220	    row_padding = (4 - (width * (bit_depth / 8)) % 4) % 4;
.LINE 220

	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,8
	XOR	A,A
	CALL	__ldivs
	LD	BC,(IX+%FFFFFFE3)
	LD	A,(IX+%FFFFFFE6)
	CALL	__lmuls
	LD	BC,4
	XOR	A,A
	CALL	__lrems
	LD	A,E
	LD	BC,HL
	LD	HL,4
	LD	E,%0
	CALL	__lsub
	LD	BC,4
	XOR	A,A
	CALL	__lrems
	LD	(IX+%FFFFFFDB),HL
	LD	(IX+%FFFFFFDE),E
;  221	
;  222		//clear_buffer(slot);
;  223		
;  224	    vdp_bitmapSelect(slot);
.LINE 224

	LD	C,(IX+%C)
	LD	B,%0
	PUSH	BC
	CALL	_vdp_bitmapSelect
	POP	BC
;  225	    putch(23); // vdu_sys
.LINE 225

	LD	BC,23
	PUSH	BC
	CALL	_putch
	POP	BC
;  226	    putch(27); // sprite command
.LINE 226

	LD	BC,27
	PUSH	BC
	CALL	_putch
	POP	BC
;  227	    putch(1); // send data to selected bitmap
.LINE 227

	LD	BC,1
	PUSH	BC
	CALL	_putch
	POP	BC
;  228	
;  229	    write16bit(width);
.LINE 229

	LD	BC,(IX+%FFFFFFE3)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  230	    write16bit(height);
.LINE 230

	LD	BC,(IX+%FFFFFFEC)
	PUSH	BC
	CALL	_write16bit
	POP	BC
;  231		
;  232	    if (bit_depth == 8) {
.LINE 232

	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,8
	XOR	A,A
	CALL	__lcmps
	JR	NZ,L_94
;  233			uint8_t a = 0xFF;
;  234			int non_pad_row = width * bit_depth / 8;
.LINE 234

	LD	HL,(IX+%FFFFFFE3)
	LD	E,(IX+%FFFFFFE6)
	LD	BC,(IX+%FFFFFFF7)
	LD	A,(IX+%FFFFFFFA)
	CALL	__lmuls
	LD	BC,8
	XOR	A,A
	CALL	__ldivs
	LD	(IX+%FFFFFFC1),HL
;  235			mos_flseek(file, image_start + ((height - 1) * (non_pad_row + row_padding)));
.LINE 235

	LD	BC,HL
	CALL	__itol
	LD	HL,(IX+%FFFFFFDB)
	LD	E,(IX+%FFFFFFDE)
	CALL	__ladd
	LD	A,E
	LD	IY,-1191	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),A
	LD	BC,-1194	; spill
	CALL	__istix
	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	A,E
	LD	BC,HL
	PUSH	BC
	LD	IY,-1179	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),A
	LD	IY,-1191	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	LD	E,A
	PUSH	BC
	LD	IY,-1179	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	LD	HL,BC
	LD	BC,-1183	; spill
	CALL	__istix
	LD	BC,-1194	; unspill
	CALL	__ildix
	LD	BC,HL
	LD	HL,BC
	LD	BC,-1183	; unspill
	PUSH	HL
	CALL	__ildix
	LD	BC,HL
	POP	HL
	CALL	__lmulu
	LD	BC,(IX+%FFFFFFB8)
	LD	A,(IX+%FFFFFFBB)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  236			
;  237	        for (y = height - 1; y >= 0; y--) {
.LINE 237

	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
	JR	L_81
L_79:
;  238	            for (x = 0; x < width; x++) {
.LINE 238

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFC7),BC
	LD	(IX+%FFFFFFCA),A
	JR	L_77
L_75:
;  239	
;  240	                index = (char) mos_fgetc(file);
.LINE 240

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fgetc
	POP	BC
	LD	(IX+%FFFFFFD6),A
;  241	                b = color_table[index * 4];
.LINE 241

	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	HL,IX
	LD	DE,-1175
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,-1178
	LD	BC,IX
	ADD	IY,BC
	LD	(IY),HL
	LD	HL,-1178
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	LD	A,(HL)
	LD	(IX+%FFFFFFC4),A
;  242	                g = color_table[index * 4 + 1];
.LINE 242

	LD	HL,-1178
	LD	BC,IX
	ADD	HL,BC
	LD	HL,(HL)
	INC	HL
	LD	A,(HL)
	LD	(IX+%FFFFFFC5),A
;  243	                r = color_table[index * 4 + 2];
.LINE 243

	LD	HL,-1178
	LD	BC,IX
	ADD	HL,BC
	LD	IY,(HL)
	LEA	HL,IY+%2
	LD	A,(HL)
	LD	(IX+%FFFFFFC6),A
;  244					
;  245					putch(r);
.LINE 245

	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;  246					putch(g);
.LINE 246

	LD	A,(IX+%FFFFFFC5)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;  247					putch(b);
.LINE 247

	LD	A,(IX+%FFFFFFC4)
	UEXT	HL
	LD	L,A
	PUSH	HL
	CALL	_putch
	POP	BC
;  248					putch(0xFF);
.LINE 248

	LD	BC,255
	PUSH	BC
	CALL	_putch
	POP	BC
	LD	HL,(IX+%FFFFFFC7)
	LD	E,(IX+%FFFFFFCA)
	LD	A,%1
	CALL	__ladd_b
	LD	(IX+%FFFFFFC7),HL
	LD	(IX+%FFFFFFCA),E
;  249					
;  250	
;  251	            }
L_77:
.LINE 251

	LD	HL,(IX+%FFFFFFC7)
	LD	E,(IX+%FFFFFFCA)
	LD	BC,(IX+%FFFFFFE3)
	LD	A,(IX+%FFFFFFE6)
	CALL	__lcmps
	JP	M,L__66
	JP	PE,L_75
	JR	L__67
L__66:
	JP	PO,L_75
L__67:
;  252				
;  253				//add_stream_to_buffer(slot,row_rgba2222,width);
;  254				mos_flseek(file, fo -> fptr - ((non_pad_row * 2) + row_padding));
.LINE 254

	LD	HL,(IX+%FFFFFFC1)
	ADD	HL,HL
	LD	BC,HL
	CALL	__itol
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+%FFFFFFDB)
	LD	A,(IX+%FFFFFFDE)
	CALL	__ladd
	LD	A,E
	LD	BC,HL
	LD	IY,(IX+%FFFFFFCB)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
;  255	            // for (i = 0; i < row_padding; i++) {
;  256	                // mos_fgetc(file);
;  257	            // }
;  258	
;  259	        }
L_81:
.LINE 259

	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,0
	XOR	A,A
	CALL	__lcmps
	JP	P,L__68
	JP	PE,L_79
	JR	L__69
L__68:
	JP	PO,L_79
L__69:
	JR	L_95
;  260	
;  261	    } else if (bit_depth == 32) {
L_94:
.LINE 261

	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,32
	XOR	A,A
	CALL	__lcmps
	JR	NZ,L_92
;  262	        
;  263			int non_pad_row = width * bit_depth / 8;
.LINE 263

	LD	HL,(IX+%FFFFFFE3)
	LD	E,(IX+%FFFFFFE6)
	LD	BC,(IX+%FFFFFFF7)
	LD	A,(IX+%FFFFFFFA)
	CALL	__lmuls
	LD	BC,8
	XOR	A,A
	CALL	__ldivs
	LD	(IX+%FFFFFFDF),HL
	LD	(IX+%FFFFFFE2),E
	LD	(IX+%FFFFFF9F),HL
;  264	        src = (char * ) malloc(width * bit_depth / 8);
.LINE 264

	LD	BC,HL
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFF0),HL
;  265			mos_flseek(file, image_start + ((height - 1) * (non_pad_row + row_padding)));
.LINE 265

	LD	BC,(IX+%FFFFFFDF)
	CALL	__itol
	LD	HL,(IX+%FFFFFFDB)
	LD	E,(IX+%FFFFFFDE)
	CALL	__ladd
	LD	A,E
	LD	IY,-1187	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),A
	LD	BC,-1190	; spill
	CALL	__istix
	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	A,E
	LD	BC,HL
	PUSH	BC
	LD	IY,-1179	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),A
	LD	IY,-1187	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	LD	E,A
	PUSH	BC
	LD	IY,-1179	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	LD	HL,BC
	LD	BC,-1183	; spill
	CALL	__istix
	LD	BC,-1190	; unspill
	CALL	__ildix
	LD	BC,HL
	LD	HL,BC
	LD	BC,-1183	; unspill
	PUSH	HL
	CALL	__ildix
	LD	BC,HL
	POP	HL
	CALL	__lmulu
	LD	BC,(IX+%FFFFFFB8)
	LD	A,(IX+%FFFFFFBB)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  266	
;  267	        for (y = height - 1; y >= 0; y--) {
.LINE 267

	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
	JR	L_85
L_83:
;  268	
;  269	            mos_fread(file, src, non_pad_row);
.LINE 269

	LD	BC,(IX+%FFFFFFDF)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  270				reorder(src, non_pad_row);
.LINE 270

	LD	BC,(IX+%FFFFFFDF)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	CALL	_reorder
	POP	BC
	POP	BC
;  271	            mos_puts(src, non_pad_row, 0);
.LINE 271

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%FFFFFFDF)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	CALL	_mos_puts
	POP	BC
	POP	BC
	POP	BC
;  272				//add_stream_to_buffer(slot,src,non_pad_row);
;  273	            mos_flseek(file, fo -> fptr - ((non_pad_row * 2) + row_padding));
.LINE 273

	LD	HL,(IX+%FFFFFFDF)
	ADD	HL,HL
	LD	BC,HL
	CALL	__itol
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+%FFFFFFDB)
	LD	A,(IX+%FFFFFFDE)
	CALL	__ladd
	LD	A,E
	LD	BC,HL
	LD	IY,(IX+%FFFFFFCB)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  274				free(src);			
.LINE 274

	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
;  275	
;  276	        }
L_85:
.LINE 276

	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,0
	XOR	A,A
	CALL	__lcmps
	JP	P,L__70
	JP	PE,L_83
	JR	L__71
L__70:
	JP	PO,L_83
L__71:
	JR	L_95
;  277	
;  278	    } else if (bit_depth == 24) {
L_92:
.LINE 278

	LD	HL,(IX+%FFFFFFF7)
	LD	E,(IX+%FFFFFFFA)
	LD	BC,24
	XOR	A,A
	CALL	__lcmps
	JR	NZ,L_95
;  279			
;  280			uint16_t new_row_size;
;  281			int non_pad_row = width * bit_depth / 8;
.LINE 281

	LD	HL,(IX+%FFFFFFE3)
	LD	E,(IX+%FFFFFFE6)
	LD	BC,(IX+%FFFFFFF7)
	LD	A,(IX+%FFFFFFFA)
	CALL	__lmuls
	LD	BC,8
	XOR	A,A
	CALL	__ldivs
	LD	(IX+%FFFFFFD7),HL
	LD	(IX+%FFFFFFDA),E
	LD	(IX+%FFFFFFAE),HL
;  282			
;  283	        src = (char * ) malloc(width * bit_depth / 8);
.LINE 283

	LD	BC,HL
	PUSH	BC
	CALL	_malloc
	POP	BC
	LD	(IX+%FFFFFFF0),HL
;  284			mos_flseek(file, image_start + ((height - 1) * (non_pad_row + row_padding)));
.LINE 284

	LD	BC,(IX+%FFFFFFD7)
	CALL	__itol
	LD	HL,(IX+%FFFFFFDB)
	LD	E,(IX+%FFFFFFDE)
	CALL	__ladd
	LD	A,E
	LD	IY,-1180	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),A
	LD	BC,-1186	; spill
	CALL	__istix
	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	A,E
	LD	BC,HL
	PUSH	BC
	LD	IY,-1179	; spill
	LD	BC,IX	; spill
	ADD	IY,BC
	LD	(IY),A
	LD	IY,-1180	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	LD	E,A
	PUSH	BC
	LD	IY,-1179	; unspill
	LD	BC,IX	; unspill
	ADD	IY,BC
	LD	A,(IY)
	POP	BC
	LD	HL,BC
	LD	BC,-1183	; spill
	CALL	__istix
	LD	BC,-1186	; unspill
	CALL	__ildix
	LD	BC,HL
	LD	HL,BC
	LD	BC,-1183	; unspill
	PUSH	HL
	CALL	__ildix
	LD	BC,HL
	POP	HL
	CALL	__lmulu
	LD	BC,(IX+%FFFFFFB8)
	LD	A,(IX+%FFFFFFBB)
	CALL	__ladd
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  285			
;  286	        for (y = height - 1; y >= 0; y--) {
.LINE 286

	LD	HL,(IX+%FFFFFFEC)
	LD	E,(IX+%FFFFFFEF)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
	JR	L_89
L_87:
;  287	
;  288	            mos_fread(file, src, non_pad_row);
.LINE 288

	LD	BC,(IX+%FFFFFFD7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fread
	POP	BC
	POP	BC
	POP	BC
;  289				reorder_and_insert(src, non_pad_row, &row_24bpp, &new_row_size, 0xFF);
.LINE 289

	LD	BC,16777215
	PUSH	BC
	PEA	IX+%FFFFFFBF
	PEA	IX+%FFFFFFBC
	LD	BC,(IX+%FFFFFFD7)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	CALL	_reorder_and_insert
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  290	            mos_puts(row_24bpp, new_row_size, 0);
.LINE 290

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%FFFFFFBF)
	CALL	__stoiu
	PUSH	HL
	LD	BC,(IX+%FFFFFFBC)
	PUSH	BC
	CALL	_mos_puts
	POP	BC
	POP	BC
	POP	BC
;  291				//add_stream_to_buffer(slot,row_24bpp,new_row_size);
;  292	            mos_flseek(file, fo -> fptr - ((non_pad_row * 2) + row_padding));
.LINE 292

	LD	HL,(IX+%FFFFFFD7)
	ADD	HL,HL
	LD	BC,HL
	CALL	__itol
	LD	E,A
	LD	HL,BC
	LD	BC,(IX+%FFFFFFDB)
	LD	A,(IX+%FFFFFFDE)
	CALL	__ladd
	LD	A,E
	LD	BC,HL
	LD	IY,(IX+%FFFFFFCB)
	LD	HL,(IY+%11)
	LD	E,(IY+%14)
	CALL	__lsub
	LD	C,E
	LD	B,%0
	PUSH	BC
	PUSH	HL
	LD	C,(IX+%FFFFFFFF)
	PUSH	BC
	CALL	_mos_flseek
	POP	BC
	POP	BC
	POP	BC
;  293				free(row_24bpp);
.LINE 293

	LD	BC,(IX+%FFFFFFBC)
	PUSH	BC
	CALL	_free
	POP	BC
;  294				free(src);
.LINE 294

	LD	BC,(IX+%FFFFFFF0)
	PUSH	BC
	CALL	_free
	POP	BC
	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
;  295	
;  296	        }		
L_89:
.LINE 296

	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,0
	XOR	A,A
	CALL	__lcmps
	JP	P,L__72
	JP	PE,L_87
	JR	L__73
L__72:
	JP	PO,L_87
L__73:
;  297			
;  298		}
L_95:
.LINE 298

;  299	
;  300		//assign_buffer_to_bitmap(slot,0,width,height);
;  301		
;  302	    mos_fclose(file);
.LINE 302

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
;  303	    free(image_buffer);
.LINE 303

	LD	BC,(IX+%FFFFFFB5)
	PUSH	BC
	CALL	_free
	POP	BC
;  304	    //return width * height;
;  305		return_info.bmp_width = width;
.LINE 305

	LD	HL,(IX+%FFFFFFE3)
	LD	(IX+%FFFFFFE7),L
	LD	(IX+%FFFFFFE8),H
;  306		return_info.bmp_height = height;
.LINE 306

	LD	HL,(IX+%FFFFFFEC)
	LD	(IX+%FFFFFFE9),L
	LD	(IX+%FFFFFFEA),H
;  307		return_info.bmp_bitdepth = bit_depth;
.LINE 307

	LD	A,(IX+%FFFFFFF7)
	LD	(IX+%FFFFFFEB),A
;  308		return return_info;
.LINE 308

	LEA	HL,IX+%6
	LD	DE,(HL)
	LEA	HL,IX+%FFFFFFE7
	LD	BC,5
	LDIR	
	LD	HL,(IX+%6)
;  309	
;  310	}
L_96:
.LINE 310

	LD	SP,IX
	POP	IX
	RET	


;**************************** _load_bmp_big ***************************
;Name                         Addr/Register   Size   Type
;_free                               IMPORT  -----   function
;_mos_puts                           IMPORT  -----   function
;_mos_flseek                         IMPORT  -----   function
;_write16bit                         IMPORT  -----   function
;_putch                              IMPORT  -----   function
;_vdp_bitmapSelect                   IMPORT  -----   function
;_mos_fgetc                          IMPORT  -----   function
;_mos_fclose                         IMPORT  -----   function
;_memcmp                             IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;_mos_fread                          IMPORT  -----   function
;_mos_getfil                         IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;color_table                        IX-1175   1024   variable
;header                              IX-151     54   variable
;non_pad_row                          IX-97      3   variable
;redMask                              IX-94      4   variable
;alphaMask                            IX-90      4   variable
;blueMask                             IX-86      4   variable
;non_pad_row                          IX-82      3   variable
;greenMask                            IX-79      4   variable
;image_buffer                         IX-75      3   variable
;image_start                          IX-72      4   variable
;row_24bpp                            IX-68      3   variable
;new_row_size                         IX-65      2   variable
;non_pad_row                          IX-63      3   variable
;b                                    IX-60      1   variable
;g                                    IX-59      1   variable
;r                                    IX-58      1   variable
;x                                    IX-57      4   variable
;fo                                   IX-53      3   variable
;biSize                               IX-50      4   variable
;color_table_size                     IX-46      4   variable
;index                                IX-42      1   variable
;O_17                                 IX-41      4   variable
;row_padding                          IX-37      4   variable
;O_15                                 IX-33      4   variable
;width                                IX-29      4   variable
;return_info                          IX-25      5   variable
;height                               IX-20      4   variable
;src                                  IX-16      3   variable
;i                                    IX-13      4   variable
;bit_depth                             IX-9      4   variable
;y                                     IX-5      4   variable
;file                                  IX-1      1   variable
;slot                                 IX+12      1   parameter
;filename                              IX+9      3   parameter


; Stack Frame Size: 1209 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "load_bmp_big",310,"_load_bmp_big"
	SEGMENT STRSECT
L__35:
	DB	"Error: could not open "
	DB	0
L__36:
	DB	"."
	DB	13,10,0
L__42:
	DB	0,0,-1,0,0
L__44:
	DB	0,-1,0,0,0
L__46:
	DB	-1,0,0,0,0
L__48:
	DB	0,0,0,-1,0
L__50:
	DB	"Error: Pixel format is NOT standard BGRA. Exiting."
	DB	10,0
L__56:
	DB	"Error: unsupported bit depth (not 8, 24 or 32-bit)."
	DB	10,0
	SEGMENT CODE
;  311	
;  312	uint16_t strtou16(const char *str) {
_strtou16:
.DEFINE "_strtou16"

.VALUE _strtou16

.CLASS 2

.TYPE 77

.ENDEF

.BEGFUNC "strtou16",312,"_strtou16"

.LINE 312

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "result"

.CLASS 65

.VALUE -2

.TYPE 13

.ENDEF

.DEFINE "digit"

.CLASS 65

.VALUE -4

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;  313	    uint16_t result = 0;
.LINE 313

	LD	(IX+%FFFFFFFE),%0
	LD	(IX+%FFFFFFFF),%0
;  314	    const uint16_t maxDiv10 = 6553;  // 65535 / 10
;  315	    const uint16_t maxMod10 = 5;     // 65535 % 10
;  316	
;  317	    while (*str == ' ' || *str == '\t' || *str == '\n') {
.LINE 317

	JR	L_100
L_101:
;  318	        str++;
.LINE 318

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  319	    }
L_100:
.LINE 319

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_101
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	Z,L_101
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	JR	Z,L_101
;  320	
;  321	    while (*str >= '0' && *str <= '9') {
.LINE 321

	JR	L_108
L_109:
;  322	        uint16_t digit = *str - '0';
.LINE 322

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	HL,IY+%FFFFFFD0
	LD	(IX+%FFFFFFFC),L
	LD	(IX+%FFFFFFFD),H
;  323	        if (result > maxDiv10 || (result == maxDiv10 && digit > maxMod10)) {
.LINE 323

	LD	BC,(IX+%FFFFFFFE)
	LD.LIS	HL,6553
	OR	A,A
	SBC.SIS	HL,BC
	JR	C,L_105
	LD.LIS	BC,6553
	LD	HL,(IX+%FFFFFFFE)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NZ,L_106
	LD	BC,(IX+%FFFFFFFC)
	LD.LIS	HL,5
	OR	A,A
	SBC.SIS	HL,BC
	JR	NC,L_106
L_105:
;  324	            return 65535;
.LINE 324

	LD.LIS	HL,65535
	JR	L_112
;  325	        }
L_106:
.LINE 325

;  326	        result = result * 10 + digit;
.LINE 326

	LD.LIS	HL,10
	LD	BC,(IX+%FFFFFFFE)
	CALL	__smulu
	LD	BC,(IX+%FFFFFFFC)
	ADD.SIS	HL,BC
	LD	(IX+%FFFFFFFE),L
	LD	(IX+%FFFFFFFF),H
;  327	        str++;
.LINE 327

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  328	    }
L_108:
.LINE 328

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L__83
	JP	PE,L_111
	JR	L__84
L__83:
	JP	PO,L_111
L__84:
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L__85
	JP	PE,L_109
	JR	L__86
L__85:
	JP	PO,L_109
L__86:
L_111:
;  329	
;  330	    return result;
.LINE 330

	LD	HL,(IX+%FFFFFFFE)
;  331	}
L_112:
.LINE 331

	LD	SP,IX
	POP	IX
	RET	


;**************************** _strtou16 ***************************
;Name                         Addr/Register   Size   Type
;digit                                 IX-4      2   variable
;result                                IX-2      2   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "strtou16",331,"_strtou16"
;  332	
;  333	uint8_t strtou8(const char *str) {
_strtou8:
.DEFINE "_strtou8"

.VALUE _strtou8

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "strtou8",333,"_strtou8"

.LINE 333

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "result"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "digit"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;  334	    uint8_t result = 0;
.LINE 334

	LD	(IX+%FFFFFFFF),%0
;  335	    const uint8_t maxDiv10 = 255 / 10;
;  336	    const uint8_t maxMod10 = 255 % 10;
;  337	
;  338	    while (*str == ' ' || *str == '\t' || *str == '\n') {
.LINE 338

	JR	L_116
L_117:
;  339	        str++;
.LINE 339

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  340	    }
L_116:
.LINE 340

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_117
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	Z,L_117
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	JR	Z,L_117
;  341	
;  342	    while (*str >= '0' && *str <= '9') {
.LINE 342

	JR	L_124
L_125:
;  343	        uint8_t digit = *str - '0';
.LINE 343

	LD	HL,(IX+%6)
	LD	A,(HL)
	SUB	A,%30
	LD	(IX+%FFFFFFFE),A
;  344	        if (result > maxDiv10 || (result == maxDiv10 && digit > maxMod10)) {
.LINE 344

	LD	A,%19
	CP	A,(IX+%FFFFFFFF)
	JR	C,L_121
	LD	A,(IX+%FFFFFFFF)
	CP	A,%19
	JR	NZ,L_122
	LD	A,%5
	CP	A,(IX+%FFFFFFFE)
	JR	NC,L_122
L_121:
;  345	            return 255;
.LINE 345

	LD	A,%FF
	JR	L_128
;  346	        }
L_122:
.LINE 346

;  347	        result = result * 10 + digit;
.LINE 347

	LD	B,%A
	LD	C,(IX+%FFFFFFFF)
	MLT	BC
	LD	A,C
	ADD	A,(IX+%FFFFFFFE)
	LD	(IX+%FFFFFFFF),A
;  348	        str++;
.LINE 348

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  349	    }
L_124:
.LINE 349

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L__96
	JP	PE,L_127
	JR	L__97
L__96:
	JP	PO,L_127
L__97:
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L__98
	JP	PE,L_125
	JR	L__99
L__98:
	JP	PO,L_125
L__99:
L_127:
;  350	
;  351	    return result;
.LINE 351

	LD	A,(IX+%FFFFFFFF)
;  352	}
L_128:
.LINE 352

	LD	SP,IX
	POP	IX
	RET	


;**************************** _strtou8 ***************************
;Name                         Addr/Register   Size   Type
;digit                                 IX-2      1   variable
;result                                IX-1      1   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "strtou8",352,"_strtou8"
;  353	
;  354	uint24_t strtou24(const char *str) {
_strtou24:
.DEFINE "_strtou24"

.VALUE _strtou24

.CLASS 2

.TYPE 78

.ENDEF

.BEGFUNC "strtou24",354,"_strtou24"

.LINE 354

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 194

.ENDEF

.DEFINE "result"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

.DEFINE "digit"

.CLASS 65

.VALUE -8

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	DEC	SP
	DEC	SP
;  355	    uint32_t result = 0;
.LINE 355

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
;  356	    const uint32_t maxDiv10 = 1677721;
;  357	    const uint32_t maxMod10 = 5;
;  358	
;  359	    while (*str == ' ' || *str == '\t' || *str == '\n') {
.LINE 359

	JR	L_132
L_133:
;  360	        str++;
.LINE 360

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  361	    }
L_132:
.LINE 361

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,32
	OR	A,A
	SBC	HL,BC
	JR	Z,L_133
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	Z,L_133
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	JR	Z,L_133
;  362		
;  363	    while (*str >= '0' && *str <= '9') {
.LINE 363

	JR	L_140
L_141:
;  364	        uint32_t digit = *str - '0';
.LINE 364

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	E,H
	LD	BC,48
	XOR	A,A
	CALL	__lsub
	LD	(IX+%FFFFFFF8),HL
	LD	(IX+%FFFFFFFB),E
;  365	        if (result > maxDiv10 || (result == maxDiv10 && digit > maxMod10)) {
.LINE 365

	LD	HL,1677721
	LD	E,%0
	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	C,L_137
	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,1677721
	XOR	A,A
	CALL	__lcmpu
	JR	NZ,L_138
	LD	HL,5
	LD	E,%0
	LD	BC,(IX+%FFFFFFF8)
	LD	A,(IX+%FFFFFFFB)
	CALL	__lcmpu
	JR	NC,L_138
L_137:
;  366	            return 16777215;
.LINE 366

	LD	HL,16777215
	JR	L_144
;  367	        }
L_138:
.LINE 367

;  368	        result = result * 10 + digit;
.LINE 368

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,10
	XOR	A,A
	CALL	__lmulu
	LD	BC,(IX+%FFFFFFF8)
	LD	A,(IX+%FFFFFFFB)
	CALL	__ladd
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
;  369	        str++;
.LINE 369

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  370	    }
L_140:
.LINE 370

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,48
	OR	A,A
	SBC	HL,BC
	JP	M,L__109
	JP	PE,L_143
	JR	L__110
L__109:
	JP	PO,L_143
L__110:
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,57
	OR	A,A
	SBC	HL,BC
	JP	P,L__111
	JP	PE,L_141
	JR	L__112
L__111:
	JP	PO,L_141
L__112:
L_143:
;  371	
;  372	    return result;
.LINE 372

	LD	HL,(IX+%FFFFFFFC)
;  373	}
L_144:
.LINE 373

	LD	SP,IX
	POP	IX
	RET	


;**************************** _strtou24 ***************************
;Name                         Addr/Register   Size   Type
;digit                                 IX-8      4   variable
;result                                IX-4      4   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 17 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "strtou24",373,"_strtou24"
;  374	
;  375	int main(int argc, char * argv[]) {
_main:
.DEFINE "_main"

.VALUE _main

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "main",375,"_main"

.LINE 375

.DEFINE "argc"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

.DEFINE "argv"

.CLASS 65

.VALUE 9

.TYPE 290

.ENDEF

.DEFINE "bitmap_slot"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -7

.TYPE 14

.ENDEF

.DEFINE "bmp"

.CLASS 65

.VALUE -12

.TAG "NONAME6"

.TYPE 8

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -18

.TYPE 14

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFDE
	LD	SP,HL
;  376	
;  377	    uint24_t x, y;
;  378		uint8_t bitmap_slot = 0;
.LINE 378

	LD	(IX+%FFFFFFFF),%0
;  379		bmp_info bmp;
;  380		
;  381		//Args = 0:binary name, 1:filname, 2:slot, 3:topleft, 3:topright
;  382		
;  383		if ((argc < 2) || (argc == 4) || (argc > 5)) {
.LINE 383

	LD	BC,2
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JP	M,L__127
	JP	PE,L_147
	JR	L__128
L__127:
	JP	PO,L_147
L__128:
	LD	BC,4
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_147
	LD	BC,(IX+%6)
	LD	HL,5
	OR	A,A
	SBC	HL,BC
	JP	P,L__129
	JP	PE,L_149
	JR	L__130
L__129:
	JP	PO,L_149
L__130:
L_147:
;  384	        printf("Usage is %s <filename> [bitmap slot] [top-left x] [top-left y]\r\n", argv[0]);
.LINE 384

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__117
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	HL,(IX+%9)
	LD	BC,(HL)
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__118
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  385	        return 0;
.LINE 385

	OR	A,A
	SBC	HL,HL
	JR	L_165
;  386	    }
L_149:
.LINE 386

;  387		
;  388		if (argc > 2) bitmap_slot = strtou8(argv[2]);
.LINE 388

	LD	BC,(IX+%6)
	LD	HL,2
	OR	A,A
	SBC	HL,BC
	JP	P,L__131
	JP	PE,L_163
	JR	L__132
L__131:
	JP	PO,L_163
L__132:
	LD	IY,(IX+%9)
	LEA	HL,IY+%6
	LD	BC,(HL)
	PUSH	BC
	CALL	_strtou8
	POP	BC
	LD	(IX+%FFFFFFFF),A
L_163:
;  389		
;  390	    //vdp_mode(8);
;  391		
;  392		if (argc == 2) {
.LINE 392

	LD	BC,2
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_162
;  393	
;  394			bmp = load_bmp_big(argv[1], 0);
.LINE 394

	LD	BC,0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	PEA	IX+%FFFFFFE9
	CALL	_load_bmp_big
	POP	BC
	POP	BC
	POP	BC
	LEA	DE,IX+%FFFFFFF4
	LD	BC,5
	LDIR	
;  395			
;  396		} else if (argc == 3) {
.LINE 396

	JR	L_164
L_162:
	LD	BC,3
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_160
;  397			
;  398			bmp = load_bmp_big(argv[1], bitmap_slot);
.LINE 398

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	PEA	IX+%FFFFFFE4
	CALL	_load_bmp_big
	POP	BC
	POP	BC
	POP	BC
	LEA	DE,IX+%FFFFFFF4
	LD	BC,5
	LDIR	
;  399			
;  400		} else if (argc == 5) {
.LINE 400

	JR	L_164
L_160:
	LD	BC,5
	LD	HL,(IX+%6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_164
;  401		
;  402			bmp = load_bmp_big(argv[1], bitmap_slot);
.LINE 402

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	IY,(IX+%9)
	LEA	HL,IY+%3
	LD	BC,(HL)
	PUSH	BC
	PEA	IX+%FFFFFFDF
	CALL	_load_bmp_big
	POP	BC
	POP	BC
	POP	BC
	LEA	DE,IX+%FFFFFFF4
	LD	BC,5
	LDIR	
;  403			
;  404			if (argv[3][0] == 'C' || argv[3][0] == 'c') x = (getsysvar_scrwidth() - bmp.bmp_width) / 2;
.LINE 404

	LD	IY,(IX+%9)
	LEA	IY,IY+%9
	LD	(IX+%FFFFFFF1),IY
	LD	HL,(IX+%FFFFFFF1)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,67
	OR	A,A
	SBC	HL,BC
	JR	Z,L_151
	LD	HL,(IX+%FFFFFFF1)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,99
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_152
L_151:
	LD	(IX+%FFFFFFDE),A
	CALL	_getsysvar_scrwidth
	LD	A,(IX+%FFFFFFDE)
	LD	BC,HL
	CALL	__stoiu
	LD	DE,HL
	LD	BC,(IX+%FFFFFFF4)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	LD	BC,2
	CALL	__idivs
	LD	(IX+%FFFFFFF9),HL
;  405			else x = strtou16(argv[4]);
.LINE 405

	JR	L_156
L_152:
	LD	IY,(IX+%9)
	LEA	HL,IY+%C
	LD	BC,(HL)
	PUSH	BC
	CALL	_strtou16
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	(IX+%FFFFFFF9),HL
L_156:
;  406			
;  407			if (argv[4][0] == 'C' || argv[4][0] == 'c') y = (getsysvar_scrheight() - bmp.bmp_height) / 2;
.LINE 407

	LD	IY,(IX+%9)
	LEA	IY,IY+%C
	LD	(IX+%FFFFFFFC),IY
	LD	HL,(IX+%FFFFFFFC)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,67
	OR	A,A
	SBC	HL,BC
	JR	Z,L_154
	LD	HL,(IX+%FFFFFFFC)
	LD	HL,(HL)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,99
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_155
L_154:
	LD	(IX+%FFFFFFDE),A
	CALL	_getsysvar_scrheight
	LD	A,(IX+%FFFFFFDE)
	LD	BC,HL
	CALL	__stoiu
	LD	DE,HL
	LD	BC,(IX+%FFFFFFF6)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	LD	BC,2
	CALL	__idivs
	LD	(IX+%FFFFFFEE),HL
;  408			else y = strtou16(argv[4]);
.LINE 408

	JR	L_157
L_155:
	LD	HL,(IX+%FFFFFFFC)
	LD	BC,(HL)
	PUSH	BC
	CALL	_strtou16
	POP	BC
	LD	BC,HL
	CALL	__stoiu
	LD	(IX+%FFFFFFEE),HL
L_157:
;  409			
;  410			vdp_bitmapDraw(bitmap_slot,x,y);
.LINE 410

	LD	BC,(IX+%FFFFFFEE)
	PUSH	BC
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_vdp_bitmapDraw
	POP	BC
	POP	BC
	POP	BC
;  411			
;  412		}
L_164:
.LINE 412

;  413	
;  414	    return 0;
.LINE 414

	OR	A,A
	SBC	HL,HL
L_165:
.LINE 415

	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_vdp_bitmapDraw                     IMPORT  -----   function
;_getsysvar_scrheight                IMPORT  -----   function
;_getsysvar_scrwidth                 IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;y                                    IX-18      3   variable
;G_1                                  IX-15      3   variable
;bmp                                  IX-12      5   variable
;x                                     IX-7      3   variable
;G_2                                   IX-4      3   variable
;bitmap_slot                           IX-1      1   variable
;argv                                  IX+9      3   parameter
;argc                                  IX+6      3   parameter


; Stack Frame Size: 46 (bytes)
;       Spill Code: -3 (instruction)


.ENDFUNC "main",415,"_main"
	SEGMENT STRSECT
L__117:
	DB	"Usage is "
	DB	0
L__118:
	DB	" <filename> [bitmap slot] [top-left x] [top-left y]"
	DB	13,10,0
	XREF _write16bit:ROM
	XREF _vdp_bitmapDraw:ROM
	XREF _vdp_bitmapSelect:ROM
	XREF _mos_getfil:ROM
	XREF _mos_flseek:ROM
	XREF _mos_fread:ROM
	XREF _mos_fgetc:ROM
	XREF _mos_fclose:ROM
	XREF _mos_fopen:ROM
	XREF _getsysvar_scrheight:ROM
	XREF _getsysvar_scrwidth:ROM
	XREF _mos_puts:ROM
	XREF _waitvblank:ROM
	XREF _putch:ROM
	XREF _memcmp:ROM
	XREF _memcpy:ROM
	XREF _malloc:ROM
	XREF _free:ROM
	XREF ___print_sendstring:ROM
	XREF ___print_xputch:ROM
	XREF ___print_uputch:ROM
	XREF __lcmps:ROM
	XREF __lcmpu:ROM
	XREF __ladd:ROM
	XREF __lsub:ROM
	XREF __idivs:ROM
	XREF __ldivs:ROM
	XREF __imuls:ROM
	XREF __lmuls:ROM
	XREF __lmulu:ROM
	XREF __smulu:ROM
	XREF __irems:ROM
	XREF __lrems:ROM
	XREF __stoiu:ROM
	XREF __itol:ROM
	XREF __ildix:ROM
	XREF __istix:ROM
	XREF __ladd_b:ROM
	XDEF _main
	XDEF _strtou24
	XDEF _strtou8
	XDEF _strtou16
	XDEF _load_bmp_big
	XDEF _reorder_and_insert
	XDEF _reorder
	XDEF _twiddle_buffer
	XDEF _flip
	XDEF _max
	XDEF _min
	XDEF _delay_secs
	END
